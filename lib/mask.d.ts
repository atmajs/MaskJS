// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../@utils/obj
//   ../../@utils/str
//   ../../@utils/is
//   ../../@utils/error
//   ../../@binding/exports
//   ../../@compo/exports
//   ../../@mask-j/jMask

declare module 'mask' {
    import { obj_getProperty, obj_setProperty, obj_extend } from '@utils/obj';
    import { str_dedent } from '@utils/str';
    import { is_Function, is_String, is_Object, is_Date } from '@utils/is';
    import { error_createClass } from '@utils/error';
    import { listeners_on, listeners_off } from 'mask/util/listeners';
    import { reporter_getNodeStack } from 'mask/util/reporters';
    import { customTag_register, customTag_registerFromTemplate, customTag_get, customTag_getAll, customStatement_register, customStatement_get, customAttr_register, customAttr_get, customUtil_register, customUtil_get } from 'mask/custom/exports';
    import { parser_ensureTemplateFunction, parser_parse, parser_parseHtml, mask_stringify, parser_ObjectLexer, parser_defineContentTag, parser_setInterpolationQuotes } from 'mask/parser/exports';
    import { mask_config } from 'mask/api/config';
    import { mask_run } from 'mask/feature/run';
    import { mask_merge } from 'mask/feature/merge';
    import { mask_optimize, mask_registerOptimizer } from 'mask/feature/optimize';
    import './statements/exports';
    import './handlers/exports';
    import { obj_removeObserver, registerValidator, registerBinding } from '@binding/exports';
    import { Component } from '@compo/exports';
    import { jMask } from '@mask-j/jMask';
    import { renderer_clearCache, renderer_renderAsync, renderer_render } from 'mask/renderer/exports';
    /**
        * @namespace mask
        */
    export const Mask: {
            /**
                * Render the mask template to document fragment or single html node
                * @param {(string|MaskDom)} template - Mask string template or Mask Ast to render from.
                * @param {*} [model] - Model Object.
                * @param {Object} [ctx] - Context can store any additional information, that custom handler may need
                * @param {IAppendChild} [container]  - Container Html Node where template is rendered into
                * @param {Object} [controller] - Component that should own this template
                * @returns {(IAppendChild|Node|DocumentFragment)} container
                * @memberOf mask
                */
            render: typeof renderer_render;
            /**
                * Same to `mask.render` but returns the promise, which is resolved when all async components
                * are resolved, or is in resolved state, when all components are synchronous.
                * For the parameters doc @see {@link mask.render}
                * @returns {Promise} Fullfills with (`IAppendChild|Node|DocumentFragment`, `Component`)
                * @memberOf mask
                */
            renderAsync: typeof renderer_renderAsync;
            parse: typeof parser_parse;
            parseHtml: typeof parser_parseHtml;
            stringify: typeof mask_stringify;
            build: (node: any, model_: any, ctx: any, container_: any, ctr_: any, children_?: any) => any;
            buildSVG: (node: any, model_: any, ctx: any, container_: any, ctr_: any, children_?: any) => any;
            run: typeof mask_run;
            merge: typeof mask_merge;
            optimize: typeof mask_optimize;
            registerOptimizer: typeof mask_registerOptimizer;
            TreeWalker: {
                    walk: (root: any, fn: any) => any;
                    walkAsync: (root: any, fn: any, done: any) => void;
                    map: (root: any, fn: any) => any;
                    superpose: (rootA: any, rootB: any, fn: any) => any;
            };
            Module: {
                    ModuleMask: import("../ref-utils/src/class").Statics<new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                            (mix?: any): void;
                            resolve(a?: any, b?: any, c?: any): any;
                            reject(error: any): any;
                            run(fn: any, ctx?: any): any;
                            all(promises: any): any;
                    } & {
                            type: any;
                            path: any;
                            location: any;
                            exports: any;
                            state: number;
                            constructor: (path: any, parent: any) => void;
                            loadModule: () => any;
                            doLoad: () => void;
                            complete_: (error: any, exports: any) => void;
                            onLoadSuccess_: (mix: any) => void;
                            onLoadError_: (error: any) => void;
                            load_: any;
                            preprocess_: any;
                            preprocessError_: any;
                            register: typeof import("../ref-utils/src/fn").fn_doNothing;
                            getExport: (property: any) => any;
                    }> & (new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                            (mix?: any): void;
                            resolve(a?: any, b?: any, c?: any): any;
                            reject(error: any): any;
                            run(fn: any, ctx?: any): any;
                            all(promises: any): any;
                    } & {
                            type: any;
                            path: any;
                            location: any;
                            exports: any;
                            state: number;
                            constructor: (path: any, parent: any) => void;
                            loadModule: () => any;
                            doLoad: () => void;
                            complete_: (error: any, exports: any) => void;
                            onLoadSuccess_: (mix: any) => void;
                            onLoadError_: (error: any) => void;
                            load_: any;
                            preprocess_: any;
                            preprocessError_: any;
                            register: typeof import("../ref-utils/src/fn").fn_doNothing;
                            getExport: (property: any) => any;
                    } & {
                            type: string;
                            scope: any;
                            source: any;
                            modules: any;
                            exports: any;
                            importItems: any;
                            load_: (path_: any) => any;
                            loadModule(): any;
                            preprocessError_(error: any, next: any): void;
                            preprocess_(mix: any, next: any): void;
                            getHandler(name: any): any;
                            queryHandler(selector: any): new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                                    scope: any;
                                    location: any;
                                    nodes: any;
                                    getHandler: (name: any) => any;
                            };
                            getExport(misc: any): any;
                    });
                    Endpoint: typeof import("./feature/modules/class/Endpoint").Endpoint;
                    createModule: typeof import("./feature/modules/Module/utils").m_createModule;
                    registerModule: typeof import("./feature/modules/Module/utils").m_registerModule;
                    registerModuleType: typeof import("./feature/modules/Module/utils").m_registerModuleType;
                    createImport: typeof import("./feature/modules/Import/utils").i_createImport;
                    isMask: typeof import("./feature/modules/types").type_isMask;
                    getType: typeof import("./feature/modules/types").type_get;
                    getModuleType: typeof import("./feature/modules/types").type_getModuleType;
                    cfg: typeof import("./feature/modules/config").m_cfg;
                    resolveLocation: typeof import("./feature/modules/utils").u_resolveLocation;
                    resolvePath: typeof import("./feature/modules/utils").u_resolvePathFromImport;
                    getDependencies: typeof import("./feature/modules/tools/dependencies").tools_getDependencies;
                    build: typeof import("./feature/modules/tools/build").tools_build;
                    clearCache: typeof import("./feature/modules/cache").cache_clear;
                    getCache: typeof import("./feature/modules/cache").cache_get;
                    reload: (path: any) => void;
                    types: any;
                    File: {
                            get: (path_: any) => any;
                            getScript: (path_: any) => any;
                            getStyle: (path_: any) => any;
                            getJson: (path_: any) => any;
                    };
            };
            File: {
                    get: (path_: any) => any;
                    getScript: (path_: any) => any;
                    getStyle: (path_: any) => any;
                    getJson: (path_: any) => any;
            };
            Di: {
                    resolve: (Type: any) => any;
                    setResolver: (di: any) => void;
                    deco: {
                            injectableClass: (mix: any) => (node: any, model: any, ctx: any, el: any, parent: any) => void;
                    };
            };
            registerHandler: typeof customTag_register;
            registerFromTemplate: typeof customTag_registerFromTemplate;
            define: import("./custom/tag").IDefineMethod;
            getHandler: typeof customTag_get;
            getHandlers: typeof customTag_getAll;
            registerStatement: typeof customStatement_register;
            getStatement: typeof customStatement_get;
            registerAttrHandler: typeof customAttr_register;
            getAttrHandler: typeof customAttr_get;
            registerUtil: typeof customUtil_register;
            getUtil: typeof customUtil_get;
            $utils: any;
            _: any;
            defineDecorator: (key: any, mix: any) => void;
            Dom: {
                    NODE: number;
                    TEXTNODE: number;
                    FRAGMENT: number;
                    COMPONENT: number;
                    CONTROLLER: number;
                    SET: number;
                    STATEMENT: number;
                    DECORATOR: number;
                    Node: new (...args: any[]) => import("./dom/INode").INode;
                    TextNode: new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                            constructor: (text: any, parent: any) => void;
                            type: number;
                            content: any;
                            parent: any;
                            sourceIndex: number;
                    };
                    Fragment: new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                            type: number;
                            nodes: any;
                            appendChild: typeof import("./dom/utils")._appendChild;
                            source: string;
                            filename: string;
                            syntax: string;
                            parent: any;
                    };
                    HtmlFragment: import("../ref-utils/src/class").Statics<new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                            type: number;
                            nodes: any;
                            appendChild: typeof import("./dom/utils")._appendChild;
                            source: string;
                            filename: string;
                            syntax: string;
                            parent: any;
                    }> & (new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                            type: number;
                            nodes: any;
                            appendChild: typeof import("./dom/utils")._appendChild;
                            source: string;
                            filename: string;
                            syntax: string;
                            parent: any;
                    } & {
                            syntax: string;
                    });
                    Component: typeof import("./dom/Component").Component;
                    DecoratorNode: new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                            constructor: (expression: any, parent: any) => void;
                            __single: boolean;
                            expression: any;
                            parent: any;
                            sourceIndex: number;
                            type: number;
                            stringify: (stream: any) => void;
                    };
            };
            /**
                * Is present only in DEBUG (not minified) version
                * Evaluates script in masks library scope
                * @param {string} script
                */
            plugin(source: any): void;
            clearCache: typeof renderer_clearCache;
            Utils: {
                    Expression: {
                            'parse': typeof import("../projects/expression/src/parser")._parse;
                            'eval': typeof import("../projects/expression/src/eval")._evaluate;
                            'varRefs': typeof import("../projects/expression/src/vars_helper").refs_extractVars;
                            'evalStatements': typeof import("../projects/expression/src/eval_statements")._evaluateStatements;
                    };
                    ensureTmplFn: typeof parser_ensureTemplateFunction;
            };
            obj: {
                    get: typeof obj_getProperty;
                    set: typeof obj_setProperty;
                    extend: typeof obj_extend;
                    addObserver: any;
                    removeObserver: typeof obj_removeObserver;
            };
            str: {
                    dedent: typeof str_dedent;
            };
            is: {
                    Function: typeof is_Function;
                    String: typeof is_String;
                    ArrayLike: typeof import("../ref-utils/src/is").is_Array;
                    Array: typeof import("../ref-utils/src/is").is_Array;
                    Object: typeof is_Object;
                    Date: typeof is_Date;
                    NODE: boolean;
                    DOM: boolean;
            };
            class: {
                    create: import("../ref-utils/src/class").ClassFactory;
                    createError: typeof error_createClass;
                    Deferred: {
                            (mix?: any): void;
                            resolve(a?: any, b?: any, c?: any): any;
                            reject(error: any): any;
                            run(fn: any, ctx?: any): any;
                            all(promises: any): any;
                    };
                    EventEmitter: () => void;
            };
            parser: {
                    ObjectLexer: typeof parser_ObjectLexer;
                    getStackTrace: typeof reporter_getNodeStack;
                    defineContentTag: typeof parser_defineContentTag;
            };
            log: {
                    info: any;
                    error: any;
                    errorWithNode: (mix: any, node: any) => void;
                    warn: any;
                    warnWithNode: (mix: any, node: any) => void;
            };
            on: typeof listeners_on;
            off: typeof listeners_off;
            delegateReload(): void;
            /**
                * Define interpolation quotes for the parser
                * Starting from 0.6.9 mask uses ~[] for string interpolation.
                * Old '#{}' was changed to '~[]', while template is already overloaded with #, { and } usage.
                * @param {string} start - Must contain 2 Characters
                * @param {string} end - Must contain 1 Character
                **/
            setInterpolationQuotes: typeof parser_setInterpolationQuotes;
            setCompoIndex(index: any): void;
            cfg: typeof mask_config;
            config: typeof mask_config;
            toHtml(dom: any): any;
            factory(compoName: any): void;
            injectable: (mix: any) => (node: any, model: any, ctx: any, el: any, parent: any) => void;
            templates: {
                    get: (id: any) => any;
                    resolve: (node: any, id: any) => any;
                    register: (id: any, nodes: any) => void;
            };
            Validators: {
                    match: (match: any) => (str: any) => boolean;
                    unmatch: (unmatch: any) => (str: any) => boolean;
                    minLength: (min: any) => (str: any) => boolean;
                    maxLength: (max: any) => (str: any) => boolean;
                    check: (condition: any, node: any) => (str: any) => any;
            };
            registerValidator: typeof registerValidator;
            BindingProviders: {};
            registerBinding: typeof registerBinding;
            Compo: import("../projects/mask-compo/src/compo/Compo").ICompo & {
                    create(...args: any[]): any;
                    createClass(): never;
                    initialize(mix: any, model?: any, ctx?: any, container?: any, parent?: any): any;
                    find: typeof import("../projects/mask-compo/src/compo/find").compo_find;
                    findAll: typeof import("../projects/mask-compo/src/compo/find").compo_findAll;
                    closest: typeof import("../projects/mask-compo/src/compo/find").compo_closest;
                    children: typeof import("../projects/mask-compo/src/compo/find").compo_children;
                    child: typeof import("../projects/mask-compo/src/compo/find").compo_child;
                    dispose: typeof import("../projects/mask-compo/src/util/compo").compo_dispose;
                    ensureTemplate: typeof import("../projects/mask-compo/src/util/compo").compo_ensureTemplate;
                    attachDisposer: typeof import("../projects/mask-compo/src/util/compo").compo_attachDisposer;
                    attach: typeof import("../projects/mask-compo/src/util/compo").compo_attach;
                    gc: {
                            using: (compo: any, x: any) => any;
                            on: (compo: any, emitter: any) => void;
                            subscribe: (compo: any, observable: any) => void;
                    };
                    element: {
                            getCompo: (el: any) => any;
                            getModel: (el: any) => any;
                    };
                    config: {
                            selectors: {
                                    '$'(compo: any, selector: any): any;
                                    'compo'(compo: any, selector: any): any;
                            };
                            setDOMLibrary(lib: any): void;
                            getDOMLibrary(): any;
                            eventDecorator(mix: any): void;
                    };
                    pipe: typeof import("../projects/mask-compo/src/compo/pipes").PipeCtor;
                    resource(compo: any): any;
                    plugin(source: any): void;
                    Dom: {
                            addEventListener: typeof import("../projects/mask-compo/src/util/dom").dom_addEventListener;
                    };
                    signal: {
                            toggle: typeof import("../projects/mask-compo/src/signal/toggle")._toggle_all;
                            emitOut: (ctr: any, slot: any, sender: any, args: any) => void;
                            emitIn: (ctr: any, slot: any, sender?: any, args?: any) => void;
                            enable: (ctr: any, slot: any) => void;
                            disable: (ctr: any, slot: any) => void;
                    };
                    slot: {
                            toggle: typeof import("../projects/mask-compo/src/signal/toggle")._toggle_single;
                            enable: (ctr: any, slot: any) => void;
                            disable: (ctr: any, slot: any) => void;
                            invoke: (ctr: any, slot: any, event: any, args: any) => any;
                            attach: typeof import("../projects/mask-compo/src/signal/compound")._compound;
                    };
                    DomLite: any;
                    pause: (compo: any, ctx: any) => () => void;
                    resume: (compo: any, ctx: any) => void;
                    await: (compo: Component) => any;
            };
            Component: typeof Component;
            jmask: typeof jMask;
            version: string;
            $: any;
            j: typeof jMask;
    };
}

declare module 'mask/util/listeners' {
    /**
        * Bind listeners to some system events:
        * - `error` Any parser or render error
        * - `compoCreated` Each time new component is created
        * - `config` Each time configuration is changed via `config` fn
        * @param {string} eveny
        * @param {function} cb
        * @memberOf mask
        * @method on
        */
    export function listeners_on(event: any, fn: any): void;
    /**
        * Unbind listener
        * - `error` Any parser or render error
        * - `compoCreated` Each time new component is created
        * @param {string} eveny
        * @param {function} [cb]
        * @memberOf mask
        * @method on
        */
    export function listeners_off(event: any, fn?: any): void;
    export function listeners_emit(event: any, v1?: any, v2?: any, v3?: any, v4?: any, v5?: any): boolean;
}

declare module 'mask/util/reporters' {
    export const log: any;
    export const log_warn: any;
    export const log_error: any;
    export function throw_(error: any): void;
    export const error_: (arg1?: any, arg2?: any, arg3?: any) => void;
    export const error_withSource: (mix: any, source: any, index: any, file: any) => void;
    export const error_withNode: (mix: any, node: any) => void;
    export const error_withCompo: (mix: any, compo: any) => void;
    export const warn_: (arg1?: any, arg2?: any, arg3?: any) => void;
    export const warn_withSource: (mix: any, source: any, index: any, file: any) => void;
    export const warn_withNode: (mix: any, node: any) => void;
    export const warn_withCompo: (mix: any, compo: any) => void;
    export const parser_error: (str: any, source: any, index?: any, token?: any, state?: any, file?: any) => void;
    export const parser_warn: (str: any, source: any, index?: any, token?: any, state?: any, file?: any) => void;
    export function reporter_createErrorNode(message: any): {
        type: number;
        tagName: string;
        attr: {
            class: string;
            style: string;
        };
        nodes: {
            type: number;
            content: any;
        }[];
    };
    export function reporter_getNodeStack(node: any): string;
    export function reporter_deprecated(id: any, message: any): void;
}

declare module 'mask/custom/exports' {
    export { custom_optimize } from 'mask/custom/optimize';
    export { custom_Utils, custom_Statements, custom_Attributes, custom_Tags, custom_Tags_global, custom_Tags_defs, custom_Parsers, custom_Parsers_Transform, custom_Optimizers } from 'mask/custom/repositories';
    export { customAttr_register, customAttr_get } from 'mask/custom/attribute';
    export { customTag_get, customTag_getAll, customTag_register, customTag_registerScoped, customTag_registerFromTemplate, customTag_registerResolver, customTag_Resolver, customTag_Compo_getHandler, customTag_define, customTag_Base } from 'mask/custom/tag';
    export { customUtil_get, customUtil_$utils, customUtil_register } from 'mask/custom/util';
    export { customStatement_register, customStatement_get } from 'mask/custom/statement';
}

declare module 'mask/parser/exports' {
    export { parser_parse } from 'mask/parser/mask/parser';
    export { parser_parseHtml } from 'mask/parser/html/parser';
    export { parser_parseAttr, parser_parseAttrObject } from 'mask/parser/mask/partials/attributes';
    export { parser_parseLiteral } from 'mask/parser/mask/partials/literal';
    export { parser_setInterpolationQuotes } from 'mask/parser/const';
    export { parser_ensureTemplateFunction } from 'mask/parser/interpolation';
    export { parser_cleanObject } from 'mask/parser/utils';
    export { parser_ObjectLexer } from 'mask/parser/object/ObjectLexer';
    export { parser_defineContentTag } from 'mask/parser/config';
    export { mask_stringify, mask_stringifyAttr } from 'mask/parser/mask/stringify';
    export { Templates } from 'mask/parser/Templates';
    export { cursor_groupEnd } from 'mask/parser/cursor';
    import './parsers/content';
    import './parsers/define';
    import './parsers/import';
    import './parsers/var';
}

declare module 'mask/api/config' {
    /**
        * Configuration Options
        * @type {object}
        * @typedef Configuration
        */
    export const __cfg: {
            /**
                * Relevant for NodeJS only. Disable/Enable compo caching.
                * @default true
                */
            allowCache: boolean;
            /**
                * Style and Script preprocessors
                * @type {object}
                * @memberOf Configuration
                */
            preprocessor: {
                    /**
                        * Transform style before using in `style` tag
                        * @type {function}
                        * @param {string} style
                        * @returns {string}
                        * @memberOf Configuration
                        */
                    style: any;
                    /**
                        * Transform script before using in `function,script,event,slot` tags
                        * @type {function}
                        * @param {string} source
                        * @returns {string}
                        * @memberOf Configuration
                        */
                    script: any;
            };
            /**
                * Base path for modules
                * @default null
                * @memberOf Configuration
                */
            base: any;
            modules: string;
            /**
                * Define custom function for getting files content by path
                * @param {string} path
                * @returns {Promise}
                * @memberOf Configuration
                */
            getFile: any;
            /**
                * Define custom function for getting script
                * @param {string} path
                * @returns {Promise} Fulfill with exports
                * @memberOf Configuration
                */
            getScript: any;
            /**
                * Define custom function for getting styles
                * @param {string} path
                * @returns {Promise} Fulfill with exports
                * @memberOf Configuration
                */
            getStyle: any;
            /**
                * Define custom function for getting jsons
                * @param {string} path
                * @returns {Promise} Fulfill with exports
                * @memberOf Configuration
                */
            getData: any;
            getJson: any;
            /**
                * Define custom function to build/combine styles
                * @param {string} path
                * @param {object} options
                * @returns {Promise} Fulfill with {string} content
                * @memberOf Configuration
                */
            buildStyle: any;
            /**
                * Define custom function to build/combine scripts
                * @param {string} path
                * @param {object} options
                * @returns {Promise} Fulfill with {string} content
                * @memberOf Configuration
                */
            buildScript: any;
            /**
                * Define custom function to build/combine jsons
                * @param {string} path
                * @param {object} options
                * @returns {Promise} Fulfill with {string} content
                * @memberOf Configuration
                */
            buildData: any;
    };
    /**
        * Get or Set configuration settings
        * - 1 `(name)`
        * - 2 `(name, value)`
        * - 3 `(object)`
        * @see @{link MaskOptions} for all options
        * @memberOf mask
        * @method config
        */
    export function mask_config(a?: any, b?: any, c?: any): any;
}

declare module 'mask/feature/run' {
    /**
      * Find all `<script type="text/mask" data-run='true'>` blocks in the page
      * and render each block into the parents container.
      *
      * The function is automatically renders the blocks
      * `<script type="text/mask" data-run='auto'>` on `DOMContentLoaded` event
      * @returns {object} Root component
      * @memberOf mask
      * @method run
     */
    export function mask_run(): any;
}

declare module 'mask/feature/merge' {
    /**
      * Join two Mask templates or DOM trees
      * @param {(string|MaskNode)} a - first template
      * @param {(string|MaskNode)} b - second template
      * @param {(MaskNode|Component)} [owner]
      * @param {object} [opts]
      * @param {bool} [opts.extending=false] - Clean the merged tree from all unused placeholders
      * @param {obj} [stats] - Output holder, if merge info is requred
      * @returns {MaskNode} New joined Mask DOM tree
      * @memberOf mask
      * @method merge
      */
    export function mask_merge(a: any, b: any, owner?: any, opts?: any, stats?: any): any;
}

declare module 'mask/feature/optimize' {
    /**
        * Run all registerd optimizers recursively on the nodes
        * @param {MaskNode} node
        * @param {function} onComplete
        * @param {mask.optimize~onComplete} done
        */
    export function mask_optimize(dom: any, done: any): void;
    /**
        * Register custom optimizer for a node name
        * @param {string} tagName - Node name
        * @param {function} visitor - Used for @see {@link mask.TreeWalker.walkSync}
        */
    export function mask_registerOptimizer(tagName: any, fn: any): void;
}

declare module 'mask/renderer/exports' {
    /**
        * Render the mask template to document fragment or single html node
        * @param {(string|MaskDom)} template - Mask string template or Mask Ast to render from.
        * @param {*} [model] - Model Object.
        * @param {Object} [ctx] - Context can store any additional information, that custom handler may need
        * @param {IAppendChild} [container]  - Container Html Node where template is rendered into
        * @param {Object} [controller] - Component that should own this template
        * @returns {(IAppendChild|Node|DocumentFragment)} container
        * @memberOf mask
        */
    export function renderer_render(mix: any, model?: any, ctx?: any, container?: any, controller?: any): HTMLElement;
    /**
        * Same to `mask.render` but returns the promise, which is resolved when all async components
        * are resolved, or is in resolved state, when all components are synchronous.
        * For the parameters doc @see {@link mask.render}
        * @returns {Promise} Fullfills with (`IAppendChild|Node|DocumentFragment`, `Component`)
        * @memberOf mask
        */
    export function renderer_renderAsync(template: any, model?: any, ctx?: any, container?: any, ctr?: any): PromiseLike<HTMLElement>;
    export function renderer_clearCache(key: any): void;
}

declare module 'mask/custom/optimize' {
    export function custom_optimize(): void;
}

declare module 'mask/custom/repositories' {
    export const custom_Utils: {};
    export const custom_Optimizers: {};
    export const custom_Statements: {};
    export const custom_Attributes: any;
    export const custom_Tags: any;
    export const custom_Tags_global: any;
    export const custom_Parsers: any;
    export const custom_Parsers_Transform: any;
    export const custom_Tags_defs: {};
}

declare module 'mask/custom/attribute' {
    /**
        * Register an attribute handler. Any changes can be made to:
        * - maskNode's template
        * - current element value
        * - controller
        * - model
        * Note: Attribute wont be set to an element.
        * @param {string} name - Attribute name to handle
        * @param {string} [mode] - Render mode `client|server|both`
        * @param {AttributeHandler} handler
        * @returns {void}
        * @memberOf mask
        * @method registerAttrHandler
        */
    export function customAttr_register(attrName: any, mix: any, Handler?: any): void;
    /**
        * Get attribute  handler
        * @param {string} name
        * @returns {AttributeHandler}
        * @memberOf mask
        * @method getAttrHandler
        */
    export function customAttr_get(attrName: any): any;
}

declare module 'mask/custom/tag' {
    /**
        * Get Components constructor from the global repository or the scope
        * @param {string} name
        * @param {object} [component] - pass a component to look in its scope
        * @returns {IComponent}
        * @memberOf mask
        * @method getHandler
        */
    export function customTag_get(name: any, ctr?: any): any;
    /**
        * Get all components constructors from the global repository and/or the scope
        * @param {object} [component] - pass a component to look also in its scope
        * @returns {object} All components in an object `{name: Ctor}`
        * @memberOf mask
        * @method getHandlers
        */
    export function customTag_getAll(ctr?: any): any;
    /**
        * Register a component
        * @param {string} name
        * @param {object|IComponent} component
        * @param {object} component - Component static definition
        * @param {IComponent} component - Components constructor
        * @returns {void}
        * @memberOf mask
        * @method registerHandler
        */
    export function customTag_register(mix: any, Handler: any): void;
    /**
        * Register components from a template
        * @param {string} template - Mask template
        * @param {object|IComponent} [component] - Register in the components scope
        * @param {string} [path] - Optionally define the path for the template
        * @returns {Promise} - Fullfills when all submodules are resolved and components are registerd
        * @memberOf mask
        * @method registerFromTemplate
        */
    export function customTag_registerFromTemplate(mix: any, Ctr?: any, path?: any): PromiseLike<void>;
    /**
        * Register a component
        * @param {object|IComponent} scopedComponent - Use components scope
        * @param {string} name - Name of the component
        * @param {object|IComponent} component - Components definition
        * @returns {void}
        * @memberOf mask
        * @method registerScoped
        */
    export function customTag_registerScoped(Ctx: any, name: any, Handler: any): void;
    export interface IDefineMethod {
            (template: string): any;
            (scopeName: string, template: string): any;
            (scopeCompo: Function, template: string): any;
            (compoName: Function, Ctor: Function | any): any;
            (scopeCompo: Function, compoName: Function, Ctor: Function | any): any;
            (scopeName: string, compoName: Function, Ctor: Function | any): any;
            (mix: string | Function, mix2?: string | Function | any, mix3?: string | Function | any): any;
    }
    /**
        * Universal component definition, which covers all the cases: simple, scoped, template
        * - 1. (template)
        * - 2. (scopedCompoName, template)
        * - 3. (scopedCtr, template)
        * - 4. (name, Ctor)
        * - 5. (scopedCtr, name, Ctor)
        * - 6. (scopedCompoName, name, Ctor)
        * @returns {void|Promise}
        * @memberOf mask
        * @method define
        */
    export const customTag_define: IDefineMethod;
    export function customTag_registerResolver(name: any): void;
    export function customTag_Compo_getHandler(name: any): any;
    export const customTag_Base: {
            async: boolean;
            attr: any;
            await: any;
            compoName: any;
            components: any;
            expression: any;
            ID: any;
            meta: any;
            node: any;
            model: any;
            nodes: any;
            parent: any;
            render: any;
            renderEnd: any;
            renderStart: any;
            tagName: any;
            type: any;
    };
    export const customTag_Resolver: (node: any, model: any, ctx: any, container: any, ctr: any) => any;
}

declare module 'mask/custom/util' {
    /**
        * Utils Repository
        * @param {string} name
        * @param {(IUtilHandler|UtilHandler)} handler
        * @memberOf mask
        * @name _
        * @category Mask Util
        */
    export const customUtil_$utils: any;
    /**
        * Register Util Handler. Template Example: `'~[myUtil: value]'`
        * @param {string} name
        * @param {(mask._.IUtilHandler|mask._.FUtilHandler)} handler
        * @memberOf mask
        * @method getUtil
        * @category Mask Util
        */
    export function customUtil_register(name: any, mix: any): void;
    /**
        * Get the Util Handler
        * @param {string} name
        * @memberOf mask
        * @method registerUtil
        * @category Mask Util
        */
    export function customUtil_get(name: any): any;
}

declare module 'mask/custom/statement' {
    /**
        * Register a statement handler
        * @param {string} name - Tag name to handle
        * @param StatementHandler} handler
        * @memberOf mask
        * @method registerStatement
        */
    export function customStatement_register(name: any, handler: any): void;
    /**
        * Get statement handler
        * @param {string} name
        * @returns {StatementHandler}
        * @memberOf mask
        * @method getStatement
        */
    export function customStatement_get(name: any): any;
}

declare module 'mask/parser/mask/parser' {
    /**
      * Parse **Mask** template to the AST tree
      * @param {string} template - Mask Template
      * @returns {MaskNode}
      * @memberOf mask
      * @method parse
      */
    export function parser_parse(template: any, filename?: any): any;
}

declare module 'mask/parser/html/parser' {
    /**
      * Parse **Html** template to the AST tree
      * @param {string} template - Html Template
      * @returns {MaskNode}
      * @memberOf mask
      * @method parseHtml
      */
    export function parser_parseHtml(str: any): any;
    export function parser_parseHtmlPartial(str: any, index: any, exitEarly: any): any[];
}

declare module 'mask/parser/mask/partials/attributes' {
    export function parser_parseAttr(str: any, start: any, end: any): {};
    export function parser_parseAttrObject(str: any, i: any, imax: any, attr: any): any;
}

declare module 'mask/parser/mask/partials/literal' {
    export function parser_parseLiteral(str: any, start: any, imax: any): any[];
}

declare module 'mask/parser/const' {
    export var interp_START: string;
    export var interp_OPEN: string;
    export var interp_CLOSE: string;
    export var interp_code_START: number;
    export var interp_code_OPEN: number;
    export var interp_code_CLOSE: number;
    export var go_tag: number;
    export var go_up: number;
    export var go_attrVal: number;
    export var go_propVal: number;
    export var go_attrHeadVal: number;
    export var state_tag: number;
    export var state_attr: number;
    export var state_prop: number;
    export var state_literal: number;
    export function parser_setInterpolationQuotes(start: any, end: any): void;
}

declare module 'mask/parser/interpolation' {
    export function parser_ensureTemplateFunction(template: string): string | ((type: any, model: any, ctx: any, element: any, ctr: any, name?: any, node?: any) => any);
}

declare module 'mask/parser/utils' {
    export function parser_cleanObject(mix: any): any;
}

declare module 'mask/parser/object/ObjectLexer' {
    export function parser_ObjectLexer(pattern: any, a?: any, b?: any, c?: any, d?: any, f?: any): any;
}

declare module 'mask/parser/config' {
    export const parser_cfg_ContentTags: {
        script: number;
        style: number;
        template: number;
        markdown: number;
    };
    export function parser_defineContentTag(name: any): void;
}

declare module 'mask/parser/mask/stringify' {
    /**
      * Serialize Mask AST to the Mask string (@analog to `JSON.stringify`)
      * @param {MaskNode} node - MaskNode
      * @param {(object|number)} [opts] - Indent count option or an object with options
      * @param {number} [opts.indent=0] - Indent count, `0` for minimization
      * @param {bool} [opts.minify=true]
      * @param {bool} [opts.minimizeAttributes=true] - Remove quotes when possible
      * @returns {string}
      * @memberOf mask
      * @method stringify
      */
    export function mask_stringify(input: any, opts?: any): any;
    export function mask_stringifyAttr(attr: any): string;
    export function format_Classes(cls: any): string;
}

declare module 'mask/parser/Templates' {
    export const Templates: {
        ensure(mix: any, ctx: {
            filename?: string;
        }): any;
    };
}

declare module 'mask/parser/cursor' {
    export function cursor_groupEnd(str: any, i: any, imax: any, startCode: any, endCode: any): any;
    export function cursor_refEnd(str: any, i: any, imax: any): any;
    export function cursor_tokenEnd(str: any, i: any, imax: any): any;
    export function cursor_quoteEnd(str: any, i: any, imax: any, char_: any): any;
    export function cursor_skipWhitespace(str: any, i_: any, imax: any): any;
    export function cursor_skipWhitespaceBack(str: any, i: any): any;
    export function cursor_goToWhitespace(str: any, i: any, imax: any): any;
}

