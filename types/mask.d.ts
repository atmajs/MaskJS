// Generated by dts-bundle v0.7.3

declare module 'mask' {
    import { _compound } from "mask/projects/mask-compo/src/signal/compound"; 
     import { _toggle_single } from "mask/projects/mask-compo/src/signal/toggle"; 
     import { _toggle_all } from "mask/projects/mask-compo/src/signal/toggle"; 
     import { dom_addEventListener } from "mask/projects/mask-compo/src/util/dom"; 
     import { PipeCtor } from "mask/projects/mask-compo/src/compo/pipes"; 
     import { Gc } from "mask/projects/mask-compo/src/compo/CompoStaticsGc"; 
     import { compo_attach } from "mask/projects/mask-compo/src/util/compo"; 
     import { compo_attachDisposer } from "mask/projects/mask-compo/src/util/compo"; 
     import { compo_ensureTemplate } from "mask/projects/mask-compo/src/util/compo"; 
     import { compo_dispose } from "mask/projects/mask-compo/src/util/compo"; 
     import { compo_child } from "mask/projects/mask-compo/src/compo/find"; 
     import { compo_children } from "mask/projects/mask-compo/src/compo/find"; 
     import { compo_closest } from "mask/projects/mask-compo/src/compo/find"; 
     import { compo_findAll } from "mask/projects/mask-compo/src/compo/find"; 
     import { compo_find } from "mask/projects/mask-compo/src/compo/find"; 
     import { ICompo } from "mask/projects/mask-compo/src/compo/Compo"; 
     import { deco_refQuery } from "mask/projects/mask-compo/src/deco/component_decorators"; 
     import { deco_refElement } from "mask/projects/mask-compo/src/deco/component_decorators"; 
     import { deco_refCompo } from "mask/projects/mask-compo/src/deco/component_decorators"; 
     import { deco_attr } from "mask/projects/mask-compo/src/deco/component_decorators"; 
     import { deco_hotkey } from "mask/projects/mask-compo/src/deco/component_decorators"; 
     import { deco_event } from "mask/projects/mask-compo/src/deco/component_decorators"; 
     import { deco_pipe } from "mask/projects/mask-compo/src/deco/component_decorators"; 
     import { deco_slotPrivate } from "mask/projects/mask-compo/src/deco/component_decorators"; 
     import { deco_slot } from "mask/projects/mask-compo/src/deco/component_decorators"; 
     import { ClassFactory } from "mask/ref-utils/src/class"; 
     import { is_Array } from "mask/ref-utils/src/is"; 
     import { _evaluateStatements } from "mask/projects/expression/src/eval_statements"; 
     import { refs_extractVars } from "mask/projects/expression/src/vars_helper"; 
     import { _evaluate } from "mask/projects/expression/src/eval"; 
     import { _parse } from "mask/projects/expression/src/parser"; 
     import { ComponentNode } from 'mask/dom/ComponentNode'; 
     import { _appendChild } from 'mask/dom/utils'; 
     import { INode } from 'mask/dom/INode'; 
     import { IDefineMethod } from 'mask/custom/tag'; 
     import { cache_get } from 'mask/feature/modules/cache'; 
     import { cache_clear } from 'mask/feature/modules/cache'; 
     import { tools_build } from 'mask/feature/modules/tools/build'; 
     import { tools_getDependencies } from 'mask/feature/modules/tools/dependencies'; 
     import { u_resolvePathFromImport } from 'mask/feature/modules/utils'; 
     import { u_resolveLocation } from 'mask/feature/modules/utils'; 
     import { m_cfg } from 'mask/feature/modules/config'; 
     import { type_getModuleType } from 'mask/feature/modules/types'; 
     import { type_get } from 'mask/feature/modules/types'; 
     import { type_isMask } from 'mask/feature/modules/types'; 
     import { i_createImport } from 'mask/feature/modules/Import/utils'; 
     import { m_registerModuleType } from 'mask/feature/modules/Module/utils'; 
     import { m_registerModule } from 'mask/feature/modules/Module/utils'; 
     import { m_createModule } from 'mask/feature/modules/Module/utils'; 
     import { Endpoint } from 'mask/feature/modules/class/Endpoint'; 
     import { IDfrConstructor } from "mask/ref-utils/src/class/Dfr"; 
     import { Statics } from "mask/ref-utils/src/class"; 
     import { obj_getProperty, obj_setProperty, obj_extend } from "mask/ref-utils/src/obj";
    import { str_dedent } from "mask/ref-utils/src/str";
    import { is_Function, is_String, is_Object, is_Date } from "mask/ref-utils/src/is";
    import { error_createClass } from "mask/ref-utils/src/error";
    import { listeners_on, listeners_off } from 'mask/util/listeners';
    import { reporter_getNodeStack } from 'mask/util/reporters';
    import { customTag_register, customTag_registerFromTemplate, customTag_get, customTag_getAll, customStatement_register, customStatement_get, customAttr_register, customAttr_get, customUtil_register, customUtil_get } from 'mask/custom/exports';
    import { parser_ensureTemplateFunction, parser_parse, parser_parseHtml, mask_stringify, parser_ObjectLexer, parser_defineContentTag, parser_setInterpolationQuotes } from 'mask/parser/exports';
    import { mask_config } from 'mask/api/config';
    import { mask_run } from 'mask/feature/run';
    import { mask_merge } from 'mask/feature/merge';
    import { mask_optimize, mask_registerOptimizer } from 'mask/feature/optimize';
    
    
    import { obj_removeObserver, registerValidator, registerBinding } from "mask/projects/mask-binding/src/exports";
    import { Component } from "mask/projects/mask-compo/src/exports";
    import { jMask } from "mask/projects/mask-j/src/jmask/jMask";
    import { renderer_clearCache, renderer_renderAsync, renderer_render } from 'mask/renderer/exports';
    
    export const Mask: {
    
            render: typeof renderer_render;
    
            renderAsync: typeof renderer_renderAsync;
            parse: typeof parser_parse;
            parseHtml: typeof parser_parseHtml;
            stringify: typeof mask_stringify;
            build: (node: any, model_: any, ctx: any, container_: any, ctr_: any, children_?: any) => any;
            buildSVG: (node: any, model_: any, ctx: any, container_: any, ctr_: any, children_?: any) => any;
            run: typeof mask_run;
            merge: typeof mask_merge;
            optimize: typeof mask_optimize;
            registerOptimizer: typeof mask_registerOptimizer;
            TreeWalker: {
                    walk: (root: any, fn: any) => any;
                    walkAsync: (root: any, fn: any, done: any) => void;
                    map: (root: any, fn: any) => any;
                    superpose: (rootA: any, rootB: any, fn: any) => any;
            };
            Module: {
                    ModuleMask: Statics<Statics<IDfrConstructor> & (new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => any)> & (new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => any);
                    Endpoint: typeof Endpoint;
                    createModule: typeof m_createModule;
                    registerModule: typeof m_registerModule;
                    registerModuleType: typeof m_registerModuleType;
                    createImport: typeof i_createImport;
                    isMask: typeof type_isMask;
                    getType: typeof type_get;
                    getModuleType: typeof type_getModuleType;
                    cfg: typeof m_cfg;
                    resolveLocation: typeof u_resolveLocation;
                    resolvePath: typeof u_resolvePathFromImport;
                    getDependencies: typeof tools_getDependencies;
                    build: typeof tools_build;
                    clearCache: typeof cache_clear;
                    getCache: typeof cache_get;
                    reload: (path: any) => void;
                    types: any;
                    File: {
                            get: (path_: any) => any;
                            getScript: (path_: any) => any;
                            getStyle: (path_: any) => any;
                            getJson: (path_: any) => any;
                    };
            };
            File: {
                    get: (path_: any) => any;
                    getScript: (path_: any) => any;
                    getStyle: (path_: any) => any;
                    getJson: (path_: any) => any;
            };
            Di: {
                    resolve(Type: any): any;
                    setResolver(di: any): void;
                    deco: {
                            injectableClass(mix: any): any;
                    };
            };
            registerHandler: typeof customTag_register;
            registerFromTemplate: typeof customTag_registerFromTemplate;
            define: IDefineMethod;
            getHandler: typeof customTag_get;
            getHandlers: typeof customTag_getAll;
            registerStatement: typeof customStatement_register;
            getStatement: typeof customStatement_get;
            registerAttrHandler: typeof customAttr_register;
            getAttrHandler: typeof customAttr_get;
            registerUtil: typeof customUtil_register;
            getUtil: typeof customUtil_get;
            $utils: any;
            _: any;
            defineDecorator: (key: any, mix: any) => void;
            Dom: {
                    NODE: number;
                    TEXTNODE: number;
                    FRAGMENT: number;
                    COMPONENT: number;
                    CONTROLLER: number;
                    SET: number;
                    STATEMENT: number;
                    DECORATOR: number;
                    Node: new (...args: any[]) => INode;
                    TextNode: new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                            constructor: (text: any, parent: any) => void;
                            type: number;
                            content: any;
                            parent: any;
                            sourceIndex: number;
                    };
                    Fragment: new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                            type: number;
                            nodes: any;
                            appendChild: typeof _appendChild;
                            source: string;
                            filename: string;
                            syntax: string;
                            parent: any;
                    };
                    HtmlFragment: Statics<new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                            type: number;
                            nodes: any;
                            appendChild: typeof _appendChild;
                            source: string;
                            filename: string;
                            syntax: string;
                            parent: any;
                    }> & (new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                            type: number;
                            nodes: any;
                            appendChild: typeof _appendChild;
                            source: string;
                            filename: string;
                            syntax: string;
                            parent: any;
                    } & {
                            syntax: string;
                    });
                    Component: typeof ComponentNode;
                    DecoratorNode: new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                            constructor: (expression: any, parent: any) => void;
                            __single: boolean;
                            expression: any;
                            parent: any;
                            sourceIndex: number;
                            type: number;
                            stringify: (stream: any) => void;
                    };
            };
    
            plugin(source: any): void;
            clearCache: typeof renderer_clearCache;
            Utils: {
                    Expression: {
                            parse: typeof _parse;
                            eval: typeof _evaluate;
                            varRefs: typeof refs_extractVars;
                            evalStatements: typeof _evaluateStatements;
                    };
                    ensureTmplFn: typeof parser_ensureTemplateFunction;
            };
            obj: {
                    get: typeof obj_getProperty;
                    set: typeof obj_setProperty;
                    extend: typeof obj_extend;
                    addObserver: (obj: any, property: string, cb: any) => void;
                    removeObserver: typeof obj_removeObserver;
            };
            str: {
                    dedent: typeof str_dedent;
            };
            is: {
                    Function: typeof is_Function;
                    String: typeof is_String;
                    ArrayLike: typeof is_Array;
                    Array: typeof is_Array;
                    Object: typeof is_Object;
                    Date: typeof is_Date;
                    NODE: boolean;
                    DOM: boolean;
            };
            class: {
                    create: ClassFactory;
                    createError: typeof error_createClass;
                    Deferred: IDfrConstructor;
                    EventEmitter: () => void;
            };
            parser: {
                    ObjectLexer: typeof parser_ObjectLexer;
                    getStackTrace: typeof reporter_getNodeStack;
                    defineContentTag: typeof parser_defineContentTag;
            };
            log: {
                    info: any;
                    error: any;
                    errorWithNode: (mix: any, node: any) => void;
                    warn: any;
                    warnWithNode: (mix: any, node: any) => void;
            };
            on: typeof listeners_on;
            off: typeof listeners_off;
            delegateReload(): void;
    
            setInterpolationQuotes: typeof parser_setInterpolationQuotes;
            setCompoIndex(index: any): void;
            cfg: typeof mask_config;
            config: typeof mask_config;
            toHtml(dom: any): any;
            factory(compoName: any): void;
            injectable: (mix: any) => any;
            deco: {
                    slot: typeof deco_slot;
                    slotPrivate: typeof deco_slotPrivate;
                    pipe: typeof deco_pipe;
                    event: typeof deco_event;
                    hotkey: typeof deco_hotkey;
                    attr: typeof deco_attr;
                    refCompo: typeof deco_refCompo;
                    refElement: typeof deco_refElement;
                    refQuery: typeof deco_refQuery;
                    inject: (mix: any) => any;
            };
            templates: {
                    get: (id: any) => any;
                    resolve: (node: any, id: any) => any;
                    register: (id: any, nodes: any) => void;
            };
            Validators: {
                    match: (match: any) => (str: any) => boolean;
                    unmatch: (unmatch: any) => (str: any) => boolean;
                    minLength: (min: any) => (str: any) => boolean;
                    maxLength: (max: any) => (str: any) => boolean;
                    check: (condition: any, node: any) => (str: any) => any;
            };
            registerValidator: typeof registerValidator;
            BindingProviders: {};
            registerBinding: typeof registerBinding;
            Compo: ICompo & {
                    create(...args: any[]): any;
                    createExt(Proto: any, args: any): any;
                    createClass(): never;
                    initialize(mix: any, model?: any, ctx?: any, container?: any, parent?: any): any;
                    find: typeof compo_find;
                    findAll: typeof compo_findAll;
                    closest: typeof compo_closest;
                    children: typeof compo_children;
                    child: typeof compo_child;
                    dispose: typeof compo_dispose;
                    ensureTemplate: typeof compo_ensureTemplate;
                    attachDisposer: typeof compo_attachDisposer;
                    attach: typeof compo_attach;
                    gc: typeof Gc;
                    element: {
                            getCompo: (el: any) => any;
                            getModel: (el: any) => any;
                    };
                    config: {
                            selectors: {
                                    $(compo: any, selector: any): any;
                                    compo(compo: any, selector: any): any;
                            };
                            setDOMLibrary(lib: any): void;
                            getDOMLibrary(): any;
                            eventDecorator(mix: any): void;
                    };
                    pipe: typeof PipeCtor;
                    resource(compo: any): any;
                    plugin(source: any): void;
                    Dom: {
                            addEventListener: typeof dom_addEventListener;
                    };
                    signal: {
                            toggle: typeof _toggle_all;
                            emitOut(ctr: any, slot: any, sender: any, args: any): void;
                            emitIn(ctr: any, slot: any, sender?: any, args?: any): void;
                            enable(ctr: any, slot: any): void;
                            disable(ctr: any, slot: any): void;
                            _trigger(ctr: any, directon: 1 | -1, slot: any, args: any): void;
                    };
                    slot: {
                            toggle: typeof _toggle_single;
                            enable(ctr: any, slot: any): void;
                            disable(ctr: any, slot: any): void;
                            invoke(ctr: any, slot: any, event: any, args: any): any;
                            attach: typeof _compound;
                    };
                    DomLite: any;
                    pause: (compo: any, ctx: any) => () => void;
                    resume: (compo: any, ctx: any) => void;
                    await: (compo: Component<any, any>) => any;
            };
            Component: typeof Component;
            jmask: typeof jMask;
            version: string;
            $: any;
            j: typeof jMask;
    };
}

declare module 'mask/projects/mask-compo/src/signal/compound' {
    export function _compound(ctr: any, slotExpression: any, cb: any): {
        slots: any;
        flags: any;
        cb: any;
        expression: any;
        constructor: (expression: any, cb: any) => void;
        signalDelegate: (name: any) => () => void;
        call: (this: any, name: any) => void;
        findSlot: (name: any) => any;
    };
}

declare module 'mask/projects/mask-compo/src/signal/toggle' {
    export function _toggle_all(ctr: any, slot: any, isActive: any): void;
    export function _toggle_single(ctr: any, slot: any, isActive: any): void;
}

declare module 'mask/projects/mask-compo/src/util/dom' {
    export function dom_addEventListener(el: any, event: any, fn: any, param?: string, ctr?: any): void;
    export function node_tryDispose(node: any): void;
    export function node_tryDisposeChildren(node: any): void;
}

declare module 'mask/projects/mask-compo/src/compo/pipes' {
    function _removeController(ctr: any): void;
    function _addController(ctr: any): void;
    export class Pipe {
        name: string;
        constructor(name: any);
        emit(signal: any, a?: any, b?: any, c?: any): void;
    }
    export function PipeCtor(name: any): Pipe;
    export namespace PipeCtor {
        var addController: typeof _addController;
        var removeController: typeof _removeController;
    }
    export const Pipes: {
        addController: typeof _addController;
        removeController: typeof _removeController;
        pipe: typeof PipeCtor;
    };
}

declare module 'mask/projects/mask-compo/src/compo/CompoStaticsGc' {
    interface IOnEmitter {
        on(...args: any[]): any;
        off(...args: any[]): any;
    }
    interface IAddEventEmitter {
        addEventListener(...args: any[]): any;
        removeEventListener(...args: any[]): any;
    }
    interface IAddEmitter {
        addListener(...args: any[]): any;
        removeListener(...args: any[]): any;
    }
    interface IBindEmitter {
        bind(...args: any[]): any;
        unbind(...args: any[]): any;
    }
    interface IObservable {
        subscribe(...args: any[]): any;
        unsubscribe?(...args: any[]): any;
        dispose?(...args: any[]): any;
    }
    export namespace Gc {
        function using(compo: any, x: {
            dispose: Function;
        }): {
            dispose: Function;
        };
        function on<T extends IOnEmitter>(compo: any, emitter: T, ...args: Parameters<T['on']>): any;
        function on<T extends IAddEventEmitter>(compo: any, emitter: T, ...args: Parameters<T['addEventListener']>): any;
        function on<T extends IAddEmitter>(compo: any, emitter: T, ...args: Parameters<T['addListener']>): any;
        function on<T extends IBindEmitter>(compo: any, emitter: T, ...args: Parameters<T['bind']>): any;
        function onMany<T extends IOnEmitter>(compo: any, emitter: T, events: {
            [key in Parameters<T['on']>[0]]?: Parameters<T['on']>[1];
        }): any;
        function onMany<T extends IAddEventEmitter>(compo: any, emitter: T, events: {
            [key in Parameters<T['addEventListener']>[0]]?: Parameters<T['addEventListener']>[1];
        }): any;
        function onMany<T extends IAddEmitter>(compo: any, emitter: T, events: {
            [key in Parameters<T['addListener']>[0]]?: Parameters<T['addListener']>[1];
        }): any;
        function onMany<T extends IBindEmitter>(compo: any, emitter: T, events: {
            [key in Parameters<T['bind']>[0]]?: Parameters<T['bind']>[1];
        }): any;
        function subscribe<T extends IObservable>(compo: any, observable: T, ...args: Parameters<T['subscribe']>): void;
    }
}

declare module 'mask/projects/mask-compo/src/util/compo' {
    import { Component } from "mask/projects/mask-compo/src/compo/Component";
    export function compo_dispose(compo: any): void;
    export function compo_detachChild(childCompo: any): void;
    export function compo_ensureTemplate(compo: any): void;
    export function compo_attachDisposer(compo: any, disposer: any): void;
    export function compo_attach(compo: Component, name: string, fn: Function): void;
    export function compo_removeElements(compo: any): void;
    export function compo_cleanElements(compo: any): void;
    export function compo_prepairAsync(dfr: any, compo: any, ctx: any): void;
    export function compo_errored(compo: any, error: any): void;
}

declare module 'mask/projects/mask-compo/src/compo/find' {
    export function compo_find<T = any>(compo: any, selector: string): T;
    export function compo_findAll<T = any>(compo: any, selector: string): T[];
    export function compo_closest<T = any>(compo: any, selector: string): T;
    export function compo_children<T = any>(compo: any, selector: string): T[];
    export function compo_child<T = any>(compo: any, selector: any): T;
}

declare module 'mask/projects/mask-compo/src/compo/Compo' {
    import { CompoStatics } from 'mask/projects/mask-compo/src/compo/CompoStatics';
    import { Component } from 'mask/projects/mask-compo/src/compo/Component';
    export interface ICompo extends Component {
        (...args: any[]): new (...args: any[]) => Component;
        new (...args: any[]): Component;
    }
    export const Compo: ICompo & typeof CompoStatics;
}

declare module 'mask/projects/mask-compo/src/deco/component_decorators' {
    import { IAttrDefinition } from "mask/projects/mask-compo/src/model/IAttrDefinition";
    export function deco_slot(opts?: {
        name?: string;
        private?: boolean;
    }): any;
    export function deco_slot(name?: string): any;
    export function deco_slotPrivate(name?: string): any;
    
    export function deco_pipe(pipeName: string, signalName?: string): (target: any, propertyKey: any, descriptor?: any) => any;
    
    export function deco_event(selector: string): (target: any, propertyKey: any, descriptor?: any) => any;
    
    export function deco_hotkey(hotkey: string): (target: any, propertyKey: any, descriptor?: any) => any;
    export function deco_attr(opts?: IAttrDefinition): (target: any, propertyKey: any, descriptor?: any) => void;
    export function deco_refCompo(selector: string): (target: any, propertyKey: any, descriptor?: any) => void;
    export function deco_refElement(selector: string): (target: any, propertyKey: any, descriptor?: any) => void;
    export function deco_refQuery(selector: string): (target: any, propertyKey: any, descriptor?: any) => void;
}

declare module 'mask/ref-utils/src/class' {
    export type Constructor<T = {}> = {
        new (...args: any[]): T;
    };
    export type Statics<T> = {
        [P in keyof T]: T[P];
    };
    export interface ClassFactory {
        <T1 extends Constructor | object, T2 extends Constructor | object = {}, T3 extends Constructor | object = {}, T4 extends Constructor | object = {}, T5 extends Constructor | object = {}>(mix1: T1, mix2?: T2, mix3?: T3, mix4?: T4, mix5?: T5): (T1 extends Constructor ? Statics<T1> : {}) & (T2 extends Constructor ? Statics<T2> : {}) & (T3 extends Constructor ? Statics<T3> : {}) & (T4 extends Constructor ? Statics<T4> : {}) & (T5 extends Constructor ? Statics<T5> : {}) & (new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => (T1 extends Constructor ? InstanceType<T1> : T1) & (T2 extends Constructor ? InstanceType<T2> : T2) & (T3 extends Constructor ? InstanceType<T3> : T3) & (T4 extends Constructor ? InstanceType<T4> : T4) & (T5 extends Constructor ? InstanceType<T5> : T5));
    }
    
    export const class_create: ClassFactory;
    export const class_createEx: (a: any, b?: any, c?: any, d?: any, e?: any, f?: any, g?: any, h?: any) => any;
}

declare module 'mask/ref-utils/src/is' {
    export function is_Function(x: any): x is Function;
    export function is_Object(x: any): x is any;
    export function is_Array<T = any>(arr: any): arr is T[];
    export const is_ArrayLike: typeof is_Array;
    export function is_String(x: any): x is string;
    export function is_notEmptyString(x: any): boolean;
    export function is_rawObject(x: any): x is object;
    export function is_Date(x: any): x is Date;
    export function is_PromiseLike<T = any>(x: any): x is PromiseLike<T>;
    export function is_Observable(x: any): boolean;
    export const is_DOM: boolean;
    export const is_NODE: boolean;
}

declare module 'mask/projects/expression/src/eval_statements' {
    export function _evaluateStatements(expr: any, model?: any, ctx?: any, ctr?: any, node?: any): any[];
}

declare module 'mask/projects/expression/src/vars_helper' {
    
    export function refs_extractVars(mix: any, model?: any, ctx?: any, ctr?: any): any;
}

declare module 'mask/projects/expression/src/eval' {
    export function _evaluate(mix: any, model?: any, ctx?: any, ctr?: any, node?: any): any;
    export function _evaluateAst(ast: any, model: any, ctx: any, ctr: any, preResults?: any): any;
}

declare module 'mask/projects/expression/src/parser' {
    export function _parse(expr: any, earlyExit?: any, node?: any): any;
    export function parser_getRef(): any;
    export function parser_getDirective(code: any): "|" | "^" | "-" | "+" | "/" | "*" | "%" | "||" | "&&" | "!" | "==" | "===" | "!=" | "!==" | ">" | ">=" | "<" | "<=" | "->" | ">>" | "&" | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 33 | 34;
    export function ast_append(current: any, next: any): any;
}

declare module 'mask/dom/ComponentNode' {
    export function ComponentNode(compoName?: any, parent?: any, controller?: any): void;
}

declare module 'mask/dom/utils' {
    export function _appendChild(el: any): void;
}

declare module 'mask/dom/INode' {
    export interface INode {
        __single: boolean;
        type: number;
        tagName: string;
        attr: {
            [name: string]: any;
        };
        props: {
            [name: string]: any;
        };
        expression: string;
        nodes: INode[];
        nextSibling: INode;
        parent: INode;
        sourceIndex: number;
        decorators: any;
        stringify(stream: any): any;
        appendChild(el: any): any;
        constructor(tagName: string, parent?: INode): any;
    }
}

declare module 'mask/custom/tag' {
    
    export function customTag_get(name: any, ctr?: any): any;
    
    export function customTag_getAll(ctr?: any): any;
    
    export function customTag_register(mix: any, Handler: any): void;
    
    export function customTag_registerFromTemplate(mix: any, Ctr?: any, path?: any): PromiseLike<void>;
    
    export function customTag_registerScoped(Ctx: any, name: any, Handler: any): void;
    export interface IDefineMethod {
        (template: string): any;
        (scopeName: string, template: string): any;
        (scopeCompo: Function, template: string): any;
        (compoName: Function, Ctor: Function | any): any;
        (scopeCompo: Function, compoName: Function, Ctor: Function | any): any;
        (scopeName: string, compoName: Function, Ctor: Function | any): any;
        (mix: string | Function, mix2?: string | Function | any, mix3?: string | Function | any): any;
    }
    
    export const customTag_define: IDefineMethod;
    export function customTag_registerResolver(name: any): void;
    export function customTag_Compo_getHandler(name: any): any;
    export const customTag_Base: {
        async: boolean;
        attr: any;
        await: any;
        compoName: any;
        components: any;
        expression: any;
        ID: any;
        meta: any;
        node: any;
        model: any;
        nodes: any;
        parent: any;
        render: any;
        renderEnd: any;
        renderStart: any;
        tagName: any;
        type: any;
    };
    export const customTag_Resolver: (node: any, model: any, ctx: any, container: any, ctr: any) => any;
}

declare module 'mask/feature/modules/cache' {
    import { Endpoint } from 'mask/feature/modules/class/Endpoint';
    export function cache_get(endpoint: Endpoint): any;
    export function cache_set(endpoint: Endpoint, module: any): any;
    export function cache_clear(path?: any): void;
    export function cache_toMap(): {};
}

declare module 'mask/feature/modules/tools/build' {
    export function tools_build(template: any, path: any, opts_?: any): any;
}

declare module 'mask/feature/modules/tools/dependencies' {
    export function tools_getDependencies(template: any, path: any, opts_?: {
        deep?: boolean;
        flattern?: boolean;
    }): any;
}

declare module 'mask/feature/modules/utils' {
    export function u_resolveLocation(ctx: any, ctr?: any, module?: any): any;
    export function u_setOption(options: any, key: any, val: any): any;
    export function u_resolveBase(): any;
    export function u_resolvePath(path: any, ctx: any, ctr: any, module: any): any;
    export function u_resolvePathFromImport(node: any, ctx?: any, ctr?: any, module?: any, makeAbs?: any): any;
    export function u_handler_getDelegate(compoName: any, compo: any, next: any): (name: any) => any;
    export function u_isNpmPath(path: any): boolean;
    export function u_resolveNpmPath(contentType: any, path: any, parentLocation: any, cb: any): void;
}

declare module 'mask/feature/modules/config' {
    export function m_cfg(mix: any, val?: any): any;
}

declare module 'mask/feature/modules/types' {
    import { Endpoint } from 'mask/feature/modules/class/Endpoint';
    export const _typeMappings: {
        script: string;
        style: string;
        data: string;
        mask: string;
        html: string;
        js: string;
        ts: string;
        es6: string;
        coffee: string;
        css: string;
        scss: string;
        sass: string;
        less: string;
        json: string;
        yml: string;
        txt: string;
        text: string;
        load: string;
    };
    export function type_isMask(endpoint: Endpoint): boolean;
    export function type_get(endpoint: Endpoint): any;
    export function type_getModuleType(endpoint: Endpoint): any;
}

declare module 'mask/feature/modules/Import/utils' {
    export function i_createImport(node: any, ctx: any, ctr: any, module?: any): any;
}

declare module 'mask/feature/modules/Module/utils' {
    export function m_createModule(node: any, ctx: any, ctr: any, parent?: any): any;
    export function m_registerModule(mix: any, endpoint: any, ctx?: any, ctr?: any, parent?: any): any;
    export function m_registerModuleType(baseModuleType: any, newType: any, mix: any): void;
}

declare module 'mask/feature/modules/class/Endpoint' {
    export class Endpoint {
        path: string;
        contentType: string;
        moduleType: string;
        constructor(path: any, contentType?: any, moduleType?: any);
    }
}

declare module 'mask/ref-utils/src/class/Dfr' {
    export interface IDfrConstructor {
        new (): typeof class_Dfr.prototype;
        resolve: typeof static_Dfr.resolve;
        reject: typeof static_Dfr.reject;
        all: typeof static_Dfr.all;
        run: typeof static_Dfr.run;
    }
    export const class_Dfr: IDfrConstructor;
    const static_Dfr: {
        resolve: (a?: any, b?: any, c?: any) => any;
        reject: (error: any) => any;
        run: (fn: any, ctx?: any) => any;
        all: (promises: any) => any;
    };
}

declare module 'mask/ref-utils/src/obj' {
    let obj_copyProperty: (target: any, source: any, key: any) => any;
    export { obj_copyProperty };
    export function obj_getProperty(obj_: any, path: string): any;
    export function obj_setProperty(obj_: any, path: any, val: any): void;
    export function obj_hasProperty(obj: any, path: any): boolean;
    export function obj_defineProperty(obj: any, path: any, dscr: any): void;
    export function obj_extend(a: any, b: any): any;
    export function obj_extendDefaults(a: any, b: any): any;
    export const obj_extendProperties: typeof obj_extend;
    export const obj_extendPropertiesDefaults: typeof obj_extend;
    export function obj_extendMany(a: any, arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any): any;
    export function obj_toFastProps(obj: any): void;
    export const _Object_create: {
        (o: object): any;
        (o: object, properties: PropertyDescriptorMap & ThisType<any>): any;
    };
    export const obj_create: {
        (o: object): any;
        (o: object, properties: PropertyDescriptorMap & ThisType<any>): any;
    };
    export function obj_defaults(target: any, defaults: any): any;
    let obj_extendDescriptors: any;
    let obj_extendDescriptorsDefaults: any;
    export { obj_extendDescriptors, obj_extendDescriptorsDefaults };
}

declare module 'mask/ref-utils/src/str' {
    export function str_format(str_: any, a?: any, b?: any, c?: any, d?: any): any;
    export function str_dedent(str: any): any;
}

declare module 'mask/ref-utils/src/error' {
    export function error_createClass(name: any, Proto: any, stackSliceFrom?: any): (...args: any[]) => void;
    export function error_formatSource(source: any, index: any, filename?: any): string;
    
    export function error_cursor(str: any, index: any): any[];
    export function error_formatCursor(lines: any, lineNum: any, rowNum: any): string;
}

declare module 'mask/util/listeners' {
    
    export function listeners_on(event: any, fn: any): void;
    
    export function listeners_off(event: any, fn?: any): void;
    export function listeners_emit(event: any, v1?: any, v2?: any, v3?: any, v4?: any, v5?: any): boolean;
}

declare module 'mask/util/reporters' {
    export const log: any;
    export const log_warn: any;
    export const log_error: any;
    export function throw_(error: any): void;
    export const error_: (arg1?: any, arg2?: any, arg3?: any) => void;
    export const error_withSource: (mix: any, source: any, index: any, file: any) => void;
    export const error_withNode: (mix: any, node: any) => void;
    export const error_withCompo: (mix: any, compo: any) => void;
    export const warn_: (arg1?: any, arg2?: any, arg3?: any) => void;
    export const warn_withSource: (mix: any, source: any, index: any, file: any) => void;
    export const warn_withNode: (mix: any, node: any) => void;
    export const warn_withCompo: (mix: any, compo: any) => void;
    export const parser_error: (str: any, source: any, index?: any, token?: any, state?: any, file?: any) => void;
    export const parser_warn: (str: any, source: any, index?: any, token?: any, state?: any, file?: any) => void;
    export function reporter_createErrorNode(message: any): {
        type: number;
        tagName: string;
        attr: {
            class: string;
            style: string;
        };
        nodes: {
            type: number;
            content: any;
        }[];
    };
    export function reporter_getNodeStack(node: any): string;
    export function reporter_deprecated(id: any, message: any): void;
}

declare module 'mask/custom/exports' {
    export { custom_optimize } from 'mask/custom/optimize';
    export { custom_Utils, custom_Statements, custom_Attributes, custom_Tags, custom_Tags_global, custom_Tags_defs, custom_Parsers, custom_Parsers_Transform, custom_Optimizers } from 'mask/custom/repositories';
    export { customAttr_register, customAttr_get } from 'mask/custom/attribute';
    export { customTag_get, customTag_getAll, customTag_register, customTag_registerScoped, customTag_registerFromTemplate, customTag_registerResolver, customTag_Resolver, customTag_Compo_getHandler, customTag_define, customTag_Base } from 'mask/custom/tag';
    export { customUtil_get, customUtil_$utils, customUtil_register } from 'mask/custom/util';
    export { customStatement_register, customStatement_get } from 'mask/custom/statement';
}

declare module 'mask/parser/exports' {
    export { parser_parse } from 'mask/parser/mask/parser';
    export { parser_parseHtml } from 'mask/parser/html/parser';
    export { parser_parseAttr, parser_parseAttrObject } from 'mask/parser/mask/partials/attributes';
    export { parser_parseLiteral } from 'mask/parser/mask/partials/literal';
    export { parser_setInterpolationQuotes } from 'mask/parser/const';
    export { parser_ensureTemplateFunction } from 'mask/parser/interpolation';
    export { parser_cleanObject } from 'mask/parser/utils';
    export { parser_ObjectLexer } from 'mask/parser/object/ObjectLexer';
    export { parser_defineContentTag } from 'mask/parser/config';
    export { mask_stringify, mask_stringifyAttr } from 'mask/parser/mask/stringify';
    export { Templates } from 'mask/parser/Templates';
    export { cursor_groupEnd } from 'mask/parser/cursor';
}

declare module 'mask/api/config' {
    
    export const __cfg: {
    
        allowCache: boolean;
    
        preprocessor: {
    
            style: any;
    
            script: any;
        };
    
        base: any;
        modules: string;
    
        getFile: any;
    
        getScript: any;
    
        getStyle: any;
    
        getData: any;
        getJson: any;
    
        buildStyle: any;
    
        buildScript: any;
    
        buildData: any;
    };
    
    export function mask_config(a?: any, b?: any, c?: any): any;
}

declare module 'mask/feature/run' {
    
    export function mask_run(): any;
}

declare module 'mask/feature/merge' {
    
    export function mask_merge(a: any, b: any, owner?: any, opts?: any, stats?: any): any;
}

declare module 'mask/feature/optimize' {
    
    export function mask_optimize(dom: any, done: any): void;
    
    export function mask_registerOptimizer(tagName: any, fn: any): void;
}

declare module 'mask/projects/mask-binding/src/exports' {
    
    
    
    
    export { Validators, registerValidator } from 'mask/projects/mask-binding/src/ValidatorProvider';
    export { obj_addObserver, obj_removeObserver } from "mask/projects/observer/src/exports";
    export const BindingProviders: {};
    export function registerBinding(name: any, Prov: any): void;
}

declare module 'mask/projects/mask-compo/src/exports' {
    export { CompoProto } from 'mask/projects/mask-compo/src/compo/CompoProto';
    export { Component } from 'mask/projects/mask-compo/src/compo/Component';
    export { Compo } from 'mask/projects/mask-compo/src/compo/Compo';
    export { domLib } from 'mask/projects/mask-compo/src/scope-vars';
}

declare module 'mask/projects/mask-j/src/jmask/jMask' {
    export function jMask(mix: any): any;
    export namespace jMask {
        var prototype: any;
    }
}

declare module 'mask/renderer/exports' {
    
    export function renderer_render<T extends HTMLElement>(mix: any, model?: any, ctx?: any, container?: any, controller?: any): T;
    
    export function renderer_renderAsync(template: any, model?: any, ctx?: any, container?: any, ctr?: any): PromiseLike<HTMLElement>;
    export function renderer_clearCache(key: any): void;
}

declare module 'mask/projects/mask-compo/src/compo/Component' {
    import { _compound } from 'mask/projects/mask-compo/src/signal/compound'; 
     import { _toggle_single } from 'mask/projects/mask-compo/src/signal/toggle'; 
     import { _toggle_all } from 'mask/projects/mask-compo/src/signal/toggle'; 
     import { dom_addEventListener } from 'mask/projects/mask-compo/src/util/dom'; 
     import { PipeCtor } from 'mask/projects/mask-compo/src/compo/pipes'; 
     import { Gc } from 'mask/projects/mask-compo/src/compo/CompoStaticsGc'; 
     import { compo_attach } from 'mask/projects/mask-compo/src/util/compo'; 
     import { compo_attachDisposer } from 'mask/projects/mask-compo/src/util/compo'; 
     import { compo_ensureTemplate } from 'mask/projects/mask-compo/src/util/compo'; 
     import { compo_dispose } from 'mask/projects/mask-compo/src/util/compo'; 
     import { compo_child } from 'mask/projects/mask-compo/src/compo/find'; 
     import { compo_children } from 'mask/projects/mask-compo/src/compo/find'; 
     import { compo_closest } from 'mask/projects/mask-compo/src/compo/find'; 
     import { compo_findAll } from 'mask/projects/mask-compo/src/compo/find'; 
     import { compo_find } from 'mask/projects/mask-compo/src/compo/find'; 
     import { deco_slot, deco_slotPrivate, deco_attr, deco_refCompo, deco_refElement, deco_refQuery, deco_pipe, deco_event, deco_hotkey } from "mask/projects/mask-compo/src/deco/component_decorators";
    import { IComponent } from "mask/projects/mask-compo/src/model/IComponent";
    import { ParametersFromSecond } from "mask/types/Parameters";
    const Component_base: new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => IComponent<any, any>;
    export class Component<TSignals extends Partial<Record<keyof TSignals, (sender: any, ...args: any) => any>> = any, TOuterModel = any> extends Component_base implements IComponent<TSignals, TOuterModel> {
            constructor();
            emitIn<TKey extends keyof TSignals>(signal: TKey, ...args: ParametersFromSecond<TSignals[TKey]>): this;
            emitOut<TKey extends keyof TSignals>(signal: TKey, ...args: ParametersFromSecond<TSignals[TKey]>): this;
            static create: (...args: any[]) => any;
            static createExt: (Proto: any, args: any) => any;
            static createClass: () => never;
            static initialize: (mix: any, model?: any, ctx?: any, container?: any, parent?: any) => any;
            static find: typeof compo_find;
            static findAll: typeof compo_findAll;
            static closest: typeof compo_closest;
            static children: typeof compo_children;
            static child: typeof compo_child;
            static dispose: typeof compo_dispose;
            static ensureTemplate: typeof compo_ensureTemplate;
            static attachDisposer: typeof compo_attachDisposer;
            static attach: typeof compo_attach;
            static gc: typeof Gc;
            static element: {
                    getCompo: (el: any) => any;
                    getModel: (el: any) => any;
            };
            static config: {
                    selectors: {
                            $(compo: any, selector: any): any;
                            compo(compo: any, selector: any): any;
                    };
                    setDOMLibrary(lib: any): void;
                    getDOMLibrary(): any;
                    eventDecorator(mix: any): void;
            };
            static pipe: typeof PipeCtor;
            static resource: (compo: any) => any;
            static plugin: (source: any) => void;
            static Dom: {
                    addEventListener: typeof dom_addEventListener;
            };
            static signal: {
                    toggle: typeof _toggle_all;
                    emitOut(ctr: any, slot: any, sender: any, args: any): void;
                    emitIn(ctr: any, slot: any, sender?: any, args?: any): void;
                    enable(ctr: any, slot: any): void;
                    disable(ctr: any, slot: any): void;
                    _trigger(ctr: any, directon: 1 | -1, slot: any, args: any): void;
            };
            static slot: {
                    toggle: typeof _toggle_single;
                    enable(ctr: any, slot: any): void;
                    disable(ctr: any, slot: any): void;
                    invoke(ctr: any, slot: any, event: any, args: any): any;
                    attach: typeof _compound;
            };
            static DomLite: any;
            static pause: (compo: any, ctx: any) => () => void;
            static resume: (compo: any, ctx: any) => void;
            static await: (compo: Component<any, any>) => any;
            static deco: {
                    pipe: typeof deco_pipe;
                    slot: typeof deco_slot;
                    slotPrivate: typeof deco_slotPrivate;
                    attr: typeof deco_attr;
                    event: typeof deco_event;
                    hotkey: typeof deco_hotkey;
                    refCompo: typeof deco_refCompo;
                    refElement: typeof deco_refElement;
                    refQuery: typeof deco_refQuery;
            };
    }
}

declare module 'mask/projects/mask-compo/src/compo/CompoStatics' {
    import { _compound } from 'mask/projects/mask-compo/src/signal/compound'; 
     import { _toggle_single } from 'mask/projects/mask-compo/src/signal/toggle'; 
     import { _toggle_all } from 'mask/projects/mask-compo/src/signal/toggle'; 
     import { PipeCtor } from 'mask/projects/mask-compo/src/compo/pipes'; 
     import { compo_dispose, compo_ensureTemplate, compo_attachDisposer, compo_attach } from 'mask/projects/mask-compo/src/util/compo';
    import { dom_addEventListener } from 'mask/projects/mask-compo/src/util/dom';
    import { compo_find, compo_findAll, compo_closest, compo_children, compo_child } from 'mask/projects/mask-compo/src/compo/find';
    import { Component } from 'mask/projects/mask-compo/src/compo/Component';
    import { Gc } from 'mask/projects/mask-compo/src/compo/CompoStaticsGc';
    export const CompoStatics: {
            create(...args: any[]): any;
            createExt(Proto: any, args: any): any;
            createClass(): never;
            initialize(mix: any, model?: any, ctx?: any, container?: any, parent?: any): any;
            find: typeof compo_find;
            findAll: typeof compo_findAll;
            closest: typeof compo_closest;
            children: typeof compo_children;
            child: typeof compo_child;
            dispose: typeof compo_dispose;
            ensureTemplate: typeof compo_ensureTemplate;
            attachDisposer: typeof compo_attachDisposer;
            attach: typeof compo_attach;
            gc: typeof Gc;
            element: {
                    getCompo: (el: any) => any;
                    getModel: (el: any) => any;
            };
            config: {
                    selectors: {
                            $(compo: any, selector: any): any;
                            compo(compo: any, selector: any): any;
                    };
                    setDOMLibrary(lib: any): void;
                    getDOMLibrary(): any;
                    eventDecorator(mix: any): void;
            };
            pipe: typeof PipeCtor;
            resource(compo: any): any;
            plugin(source: any): void;
            Dom: {
                    addEventListener: typeof dom_addEventListener;
            };
            signal: {
                    toggle: typeof _toggle_all;
                    emitOut(ctr: any, slot: any, sender: any, args: any): void;
                    emitIn(ctr: any, slot: any, sender?: any, args?: any): void;
                    enable(ctr: any, slot: any): void;
                    disable(ctr: any, slot: any): void;
                    _trigger(ctr: any, directon: 1 | -1, slot: any, args: any): void;
            };
            slot: {
                    toggle: typeof _toggle_single;
                    enable(ctr: any, slot: any): void;
                    disable(ctr: any, slot: any): void;
                    invoke(ctr: any, slot: any, event: any, args: any): any;
                    attach: typeof _compound;
            };
            DomLite: any;
            pause: (compo: any, ctx: any) => () => void;
            resume: (compo: any, ctx: any) => void;
            await: (compo: Component<any, any>) => any;
    };
}

declare module 'mask/projects/mask-compo/src/model/IAttrDefinition' {
    export interface IAttrDefinition {
        default?: any;
        type?: string;
        name?: string;
    }
}

declare module 'mask/custom/optimize' {
    export function custom_optimize(): void;
}

declare module 'mask/custom/repositories' {
    export const custom_Utils: {};
    export const custom_Optimizers: {};
    export const custom_Statements: {};
    export const custom_Attributes: any;
    export const custom_Tags: any;
    export const custom_Tags_global: any;
    export const custom_Parsers: any;
    export const custom_Parsers_Transform: any;
    export const custom_Tags_defs: {};
}

declare module 'mask/custom/attribute' {
    
    export function customAttr_register(attrName: any, mix: any, Handler?: any): void;
    
    export function customAttr_get(attrName: any): any;
}

declare module 'mask/custom/util' {
    
    export const customUtil_$utils: any;
    
    export function customUtil_register(name: any, mix: any): void;
    
    export function customUtil_get(name: any): any;
}

declare module 'mask/custom/statement' {
    
    export function customStatement_register(name: any, handler: any): void;
    
    export function customStatement_get(name: any): any;
}

declare module 'mask/parser/mask/parser' {
    
    export function parser_parse(template: any, filename?: any): any;
}

declare module 'mask/parser/html/parser' {
    
    export function parser_parseHtml(str: any): any;
    export function parser_parseHtmlPartial(str: any, index: any, exitEarly: any): any[];
}

declare module 'mask/parser/mask/partials/attributes' {
    export function parser_parseAttr(str: any, start: any, end: any): {};
    export function parser_parseAttrObject(str: any, i: any, imax: any, attr: any): any;
}

declare module 'mask/parser/mask/partials/literal' {
    export function parser_parseLiteral(str: any, start: any, imax: any): any[];
}

declare module 'mask/parser/const' {
    export var interp_START: string;
    export var interp_OPEN: string;
    export var interp_CLOSE: string;
    export var interp_code_START: number;
    export var interp_code_OPEN: number;
    export var interp_code_CLOSE: number;
    export var go_tag: number;
    export var go_up: number;
    export var go_attrVal: number;
    export var go_propVal: number;
    export var go_attrHeadVal: number;
    export var state_tag: number;
    export var state_attr: number;
    export var state_prop: number;
    export var state_literal: number;
    export function parser_setInterpolationQuotes(start: any, end: any): void;
}

declare module 'mask/parser/interpolation' {
    export function parser_ensureTemplateFunction(template: string): string | ((type: any, model: any, ctx: any, element: any, ctr: any, name?: any, node?: any) => any);
}

declare module 'mask/parser/utils' {
    export function parser_cleanObject(mix: any): any;
}

declare module 'mask/parser/object/ObjectLexer' {
    export function parser_ObjectLexer(pattern: any, a?: any, b?: any, c?: any, d?: any, f?: any): any;
}

declare module 'mask/parser/config' {
    export const parser_cfg_ContentTags: {
        script: number;
        style: number;
        template: number;
        markdown: number;
    };
    export function parser_defineContentTag(name: any): void;
}

declare module 'mask/parser/mask/stringify' {
    
    export function mask_stringify(input: any, opts?: any): any;
    export function mask_stringifyAttr(attr: any): string;
    export function format_Classes(cls: any): string;
}

declare module 'mask/parser/Templates' {
    export const Templates: {
        ensure(mix: any, ctx: {
            filename?: string;
        }): any;
    };
}

declare module 'mask/parser/cursor' {
    export function cursor_groupEnd(str: any, i: any, imax: any, startCode: any, endCode: any): any;
    export function cursor_refEnd(str: any, i: any, imax: any): any;
    export function cursor_tokenEnd(str: any, i: any, imax: any): any;
    export function cursor_quoteEnd(str: any, i: any, imax: any, char_: any): any;
    export function cursor_skipWhitespace(str: any, i_: any, imax: any): any;
    export function cursor_skipWhitespaceBack(str: any, i: any): any;
    export function cursor_goToWhitespace(str: any, i: any, imax: any): any;
}

declare module 'mask/projects/mask-binding/src/ValidatorProvider' {
    export const ValidatorProvider: {
        getFnFromModel: typeof fn_fromModelWrapp;
        getFnByName: typeof fn_byName;
        validate: typeof validate;
        validateUi: (fns: any, val: any, ctr: any, el: any, oncancel: any) => any;
    };
    function validate(fns: any, val: any, ctr: any): any;
    function fn_fromModelWrapp(model: any, prop: any): () => any;
    function fn_byName(name: any, param: any, message: any): (val: any, ctr: any) => any;
    export const Validators: {
        match: (match: any) => (str: any) => boolean;
        unmatch: (unmatch: any) => (str: any) => boolean;
        minLength: (min: any) => (str: any) => boolean;
        maxLength: (max: any) => (str: any) => boolean;
        check: (condition: any, node: any) => (str: any) => any;
    };
    export function registerValidator(type: any, fn: any): void;
}

declare module 'mask/projects/observer/src/exports' {
    export { obj_addObserver, obj_hasObserver, obj_removeObserver, obj_addMutatorObserver, obj_removeMutatorObserver, obj_lockObservers, obj_unlockObservers } from 'mask/projects/observer/src/obj_observe';
    export { expression_bind, expression_unbind, expression_callFn, expression_createBinder, expression_createListener, expression_getHost } from 'mask/projects/observer/src/expression';
}

declare module 'mask/projects/mask-compo/src/compo/CompoProto' {
    import { IComponent } from "mask/projects/mask-compo/src/model/IComponent";
    export const CompoProto: IComponent<any, any>;
}

declare module 'mask/projects/mask-compo/src/scope-vars' {
    export var domLib: any;
    export var Class: any;
    export function _mask_ensureTmplFn(value: any): any;
    export function _resolve_External(key: any): any;
    export function setDomLib(lib: any): void;
}

declare module 'mask/projects/mask-compo/src/model/IComponent' {
    import { INode } from "mask/dom/INode";
    import { ParametersFromSecond } from "mask/types/Parameters";
    export interface IComponent<TSignals extends Partial<Record<keyof TSignals, <TSender = any>(sender: TSender, ...args: any) => any>> = any, TOuterModel = any> {
        type: number;
        __constructed: boolean;
        __resource: any;
        __frame: number;
        __tweens: number;
        ID: number;
        tagName: string;
        compoName: string;
        node: INode;
        nodes: INode | INode[];
        parent: IComponent;
        components: IComponent[];
        expression: string;
        attr: {
            [key: string]: string | Function | any;
        };
        model: TOuterModel;
        scope: any;
        $: JQuery;
        slots: {
            [key: string]: Function;
        };
        pipes: {
            [pipe: string]: {
                [key: string]: Function;
            };
        };
        compos: {
            [key: string]: string | IComponent | any;
        };
        events: {
            [key: string]: Function;
        };
        hotkeys: {
            [key: string]: Function;
        };
        async: boolean;
        await: Function;
        resume: Function;
        disposed: boolean;
        meta: {
            mode: null;
            modelMode: null;
            attributes: null;
            properties: null;
            arguments: null;
            template: null;
            serializeNodes: null;
            readAttributes: null;
            readProperties: null;
            readArguments: null;
        };
        getAttribute?<T = any>(key: string): T;
        setAttribute?(key: string, val: any): any;
        onAttributeSet?(name: string, val: any): any;
        renderStart?(model: TOuterModel, ctx: any, container: HTMLElement): Promise<any> | void;
        onRenderStart?(model: TOuterModel, ctx: any, container: HTMLElement): Promise<any> | void;
        renderStartClient?(model: TOuterModel, ctx: any, container: HTMLElement): Promise<any> | void;
        onRenderStartClient?(model: TOuterModel, ctx: any, container: HTMLElement): Promise<any> | void;
        onRenderEnd?(elements: HTMLElement[], model: TOuterModel, ctx: any, container: HTMLElement): any;
        onRenderEndServer?(elements: HTMLElement[], model: TOuterModel, ctx: any, container: HTMLElement): any;
        renderEnd?(elements: HTMLElement[], model: TOuterModel, ctx: any, container: HTMLElement): any;
        onEnterFrame?: Function;
        render(elements: HTMLElement[], model: TOuterModel, ctx: any, container: HTMLElement): any;
        appendTo?(el: HTMLElement): any;
        append?(template: string, model: TOuterModel, selector: string): any;
        find<T = IComponent>(selector: string): T;
        findAll<T = IComponent>(selector: string): T[];
        closest<T = IComponent>(selector: any): T;
        on(type: string, selector: string, fn: Function): any;
        remove(): void;
        slotState(slotName: string, isActive?: boolean): this;
        signalState(signalName: string, isActive?: boolean): this;
        emitIn<TKey extends keyof TSignals>(signal: TKey | any, ...args: ParametersFromSecond<TSignals[TKey]>): this;
        emitOut<TKey extends keyof TSignals>(signal: TKey | any, ...args: ParametersFromSecond<TSignals[TKey]>): this;
        $scope<T = any>(key: string): T;
        $eval<T = any>(expr: string, model?: any, ctx?: any): T;
        attach(name: keyof this, fn: Function): any;
        serializeState(): {
            scope: any;
        };
        deserializeState(bundle?: any): any;
    }
}

declare module 'mask/types/Parameters' {
    export type ParametersFromSecond<T extends (x: any, ...args: any) => any> = T extends (x: any, ...args: infer P) => any ? P : never;
}

declare module 'mask/projects/observer/src/obj_observe' {
    namespace AddObserver {
        function add(obj: any, property: string, cb: any): void;
    }
    export const obj_addObserver: typeof AddObserver.add;
    export function obj_hasObserver(obj: any, property: any, callback: any): boolean;
    export function obj_removeObserver(obj: any, property: any, callback?: any): void;
    export function obj_lockObservers(obj: any): void;
    export function obj_unlockObservers(obj: any): void;
    export function obj_addMutatorObserver(obj: any, cb: any): void;
    export function obj_removeMutatorObserver(obj: any, cb: any): void;
}

declare module 'mask/projects/observer/src/expression' {
    export function expression_bind(expr: any, model: any, ctx: any, ctr: any, cb: any): void;
    export function expression_unbind(expr: any, model: any, ctr: any, cb: any): void;
    export function expression_callFn(accessor: any, model: any, ctx: any, ctr: any, args: any): any;
    
    export function expression_createBinder(expr: any, model: any, ctx: any, ctr: any, fn: any): () => void;
    export function expression_createListener(callback: any): () => void;
    export var expression_getHost: any;
}

