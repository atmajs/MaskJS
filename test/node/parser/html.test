UTest({
	'content' () {
		var template = `Lorem ipsum doler!`;
		var node = Mask.parseHtml(template);
		eq_(node.content, template);
	},
	'node':{
		'single notation' () {
			var template = `<div/>`;
			var node = Mask.parseHtml(template);
			eq_(node.tagName, 'div');
		},
		'open-close notation' () {
			var template = `<div > </div>`;
			var node = Mask.parseHtml(template);
			eq_(node.tagName, 'div');
		},
		'attributes' () {
			[
				`<div id='qux' data-name="foo bar daz" checked='checked'> </div>`,
				`
					<div
						id = 'qux'
						data-name = "foo bar daz"
						checked
					> </div>
				`,
				`
					<div
						checked id = qux
						data-name = 'foo bar daz'
					> </ div >
				`,
			].forEach(str => {
				var node = Mask.parseHtml(str);
				eq_(node.tagName, 'div');
				has_(node.attr, {
					'id': 'qux',
					'data-name': 'foo bar daz',
					'checked': 'checked'
				});
			});
		}
	},
	'children': {
		'text' () {
			var template = `<span>Foo</span>`;
			var node = Mask.parseHtml(template);
			eq_(node.tagName, 'span');
			eq_(node.nodes[0].content, 'Foo');
		},
		'nodes' () {
			var template = `
				<section>
					Lorem <li>ipsum</li> doler
				</section>
			`;

			var node = Mask.parseHtml(template);
			eq_(node.tagName, 'section');
			var nodes = node.nodes;
			eq_(nodes.length, 3);
			eq_(nodes[0].content.trim(), 'Lorem');
			eq_(nodes[1].tagName, 'li');
			eq_(nodes[1].nodes[0].content, 'ipsum');
			eq_(nodes[2].content.trim(), 'doler');
		},
		'implies close' () {
			var template = `
				<ul>
					<li>A
					<li><div>B
				</ul>
			`;

			var node = Mask.parseHtml(template);
			eq_(node.tagName, 'ul');
			eq_(node.nodes[0].tagName, 'li');
			eq_(node.nodes[0].nodes[0].content.trim(), 'A');
		}
	},
	'expression' () {
		var template = `
			<if expression='foo%2 === 1'>Hello</if>
		`;

		var node = Mask.parseHtml(template);
		eq_(node.tagName, 'if');
		eq_(node.expression, 'foo%2 === 1');
		eq_(node.type, mask.Dom.STATEMENT);
		eq_(node.nodes[0].content, 'Hello')
	},
	'parsers': {
		'method' () {
			var template = `
				<mask>
				function foo() {
					var a = 10;
				}
				</mask>
			`;

			var node = Mask.parseHtml(template);
			eq_(node.tagName, 'function');
			eq_(node.body.trim(), 'var a = 10;');
		}
	},
	'embedded html': {
		'simple' () {
			var template = `
				div {
					<span>Hello</span>
				}
			`;
			return UTest
				.domtest
				.use('jmask')
				.process(Mask.parse(template), `
					filter('div') {
						find('span') > text ("Hello");
					}
				`);
		},
		'nested mix' () {
			var template = `
				<section>
					<mask>
						h4.header {
							<span>Foo</span>
						}
					</mask>
				</section>
			`;
			return UTest
				.domtest
				.use('jmask')
				.process(Mask.parse(template), `
					find('section') >
						find('.header') >
							find ('span') >
								text ("Foo");
				`);
		}
	},
	$config: {
		breakOnError: true,
	},
	'!HTML Node Parser Tests': (function(){
		var tests = {
			$config: {
				breakOnError: true,
			}
		};
		var html = {} || require('./fixtures/html.js');
		for (var test in html) {
			tests[test] = createTest(html[test]);
		}

		var html = require('./fixtures/parser.js');
		for (var test in html) {
			tests[test] = createTest(html[test]);
		}

		function createTest(data) {
			function compare(a, b) {
				if (typeof b === 'string') {
					eq_(a.type, Mask.Dom.TEXTNODE);
					eq_(a.content, b.data);
					return;
				}
				if (b.type === 'text') {
					eq_(a.content, b.data);
					return;
				}
				eq_(a.tagName, b.name);
				if (b.attributes) {
					for(var key in b.attributes) {
						eq_(a.attr[key], b.attributes[key] || key);
					}
				}
				if (b.children) {
					var nodes = a.nodes || [];
					var index = 0;
					b.children.forEach(child => {
						if (child.type === 'comment') {
							return;
						}
						compare(nodes[index++], child);
					});
				}
			};
			return function(){
				data.html && check(data.html, mask.parseHtml);
				data.mask && check(data.mask, mask.parse);

				function check (content, parser) {
					var ast = parser(content);
					var expected = data.expected;
					var nodes = ast.type === Mask.Dom.FRAGMENT ? ast.nodes : [ ast ];
					expected.forEach((child, index) => {
						compare(nodes[index], child);
					});
				}
			};
		};
		return tests;
	}())
});