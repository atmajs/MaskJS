UTest({
	'$before' () {
		mask.off('error');
	},
	$after () {
		mask.off('error');
	},
	'function node': {
		'decorator as a function': {
			'should decorate with simple method' () {

				var template = `

					[LetterB]
					function letter (str) {
						return (str || '') + 'x';
					}

					h1 > '~[$.letter("a")]'
					h2 > '~[$.letter("c")]'
				`;

				var spyDecorator, spyInner;

				spyDecorator = sinon.spy(function (fn) {
					return spyInner = sinon.spy(function (str) {
						str = (str || '') + 'b';
						return fn(str);
					});
				});
				mask.defineDecorator ('LetterB', spyDecorator)

				var dom = mask.render(template);

				eq_(spyDecorator.callCount, 1);
				eq_(spyInner.callCount, 2);

				deepEq_(spyInner.args[0], ['a']);
				deepEq_(spyInner.args[1], ['c']);

				return UTest.domtest(dom, `
					find ('h1') > text ('abx');
					find ('h2') > text ('cbx');
				`);
			},
			'should decorate with a factory method' () {
				var template = `
					[ Letter ( 'f' ) ]
					function letter (str) {
						return (str || '') + 'x';
					}
					h1 > '~[$.letter("p")]'
				`;

				var spyFactory, spyDecorator, spyInner;

				spyFactory = sinon.spy(function (val){
					return spyDecorator = sinon.spy(function (fn) {
						return spyInner = sinon.spy(function (str) {
							str = val + (str || '');
							return fn(str);
						});
					});
				});
				mask.defineDecorator ('Letter', spyFactory)

				var dom = mask.render(template);

				eq_(spyFactory.callCount, 1);
				eq_(spyDecorator.callCount, 1);
				eq_(spyInner.callCount, 1);

				deepEq_(spyInner.args[0], ['p']);

				return UTest.domtest(dom, `
					find ('h1') > text ("fpx");
				`);
			}
		},
		'decorate with interceptors': {
			'should override arguments and return' () {
				var template = `

					[LetterB]
					function letter (str) {
						return (str || '') + 'x';
					}

					h1 > '~[$.letter("a")]'
				`;

				var spyBefore, spyAfter;

				var decorator = {
					beforeInvoke: spyBefore = sinon.spy(function (letter) {
						return [ letter + 'b' ]
					}),
					afterInvoke: spyAfter = sinon.spy(function (result) {
						return result + 'B';
					})
				};

				mask.defineDecorator ('LetterB', decorator)

				var dom = mask.render(template);

				eq_(spyBefore.callCount, 1);
				eq_(spyAfter.callCount, 1);

				deepEq_(spyBefore.args[0], ['a']);
				deepEq_(spyAfter.args[0], ['abx']);

				return UTest.domtest(dom, `
					find ('h1') > text ('abxB');
				`);			
			}
		}
	},
	'element node': {
		'should change text before render' () {
				var template = `

					[UpperCase]
					div > 'Hello';
					
				`;

				mask.defineDecorator ('UpperCase', {
					beforeRender (node) {
						var str = mask.j(node).text().toUpperCase();
						mask.j(node).text(str);
					}
				});

				var dom = mask.render(template);
				return UTest.domtest(dom, `
					find(div) > text ('HELLO');
				`);			
		},
		'should change bg and fore color' () {
			var template = `

				[RedBackground]
				[GreenColor]
				div > 'Hello';				
			`;

			mask.defineDecorator ('RedBackground', function (el) {
				el.style.backgroundColor = 'red';
				el.textContent += 'R';
			});
			mask.defineDecorator ('GreenColor', function (el) {
				el.style.color = 'green';
				el.textContent += 'G';
			});

			var dom = mask.render(template);
			return UTest.domtest(dom, `
				find(div) {
					css ('color', 'green');
					css ('background-color', 'red');
					text ('HelloGR');
				}
			`);	
		}
	},

	'inside `define`': {
		'function node' () {
			var template = `
				define Foo {
					[UpperCase]
					function getName () {
						return 'foo';
					}
					h1 > '~[$.getName()]'
				}
				Foo;
			`;

			mask.defineDecorator ('UpperCase', {
				afterInvoke (str) {
					return str.toUpperCase();
				}
			});

			var dom = mask.render(template);
			return UTest.domtest(dom, `
				find (h1) > text ('FOO');
			`)
		},
		'element node' () {
			var template = `
				define Bar {
					function getName () {
						return 'bar';
					}
					[UpperCase]
					h1 > '~[$.getName()]'
				}
				Bar;
			`;

			mask.defineDecorator ('UpperCase', {
				afterRender (el) {
					el.textContent = el.textContent.toUpperCase();
				}
			});

			var dom = mask.render(template);
			return UTest.domtest(dom, `
				find (h1) > text ('BAR');
			`)
		},

		'should notify unacceptable node' () {
			var template = `
				define Bar {
					var test = true;
					[UpperCase]
					if (test) {
						h1 > 'OK'
					}
				}
				Bar;
			`;

			mask.defineDecorator ('UpperCase', {
				afterRender (el) { }
			});

			
			mask.on('error', assert.await(error => {
				var msg = error.message;
				has_(msg, 'UpperCase');
				has_(msg, 'support');
			}))
			var dom = mask.render(template);
			return UTest.domtest(dom, `
				find (h1) > text ('OK');
			`)
		}
	}
})