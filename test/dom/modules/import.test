// use default module loader
mask.config('modules', 'default');

UTest({
	'parser': {
		'all' () {
			var imports = mask.parse(`
				import * as foo3 from '/test/tmpl/a.mask';
				foo3;
			`);
			eq_(imports.tagName, 'imports');

			var node = imports.nodes[0];
			has_(node, {
				tagName: 'import',
				path: '/test/tmpl/a.mask',
				alias: 'foo3'
			});
		},
		'compos' () {
			var imports = mask.parse(`
				import foo as baz3 from '/test/tmpl/a.mask';
				baz3;
			`);
			eq_(imports.tagName, 'imports');

			var node = imports.nodes[0];
			has_(node, {
				tagName: 'import',
				path: '/test/tmpl/a.mask',
				exports: [
					{
						name: 'foo',
						alias: 'baz3'
					}
				]
			});
		},
		'generic path' () {
			var imports = mask.parse(`
				import foo3 from 'compo/bar';
				import * as Some from '../compo/a';
				baz3;
			`);
			eq_(imports.tagName, 'imports');

			var node = imports.nodes[0];
			has_(node, {
				tagName: 'import',
				path: 'compo/bar',
				exports: [{
					name: 'foo3'
				}]
			});

			var node = imports.nodes[1];
			has_(node, {
				tagName: 'import',
				path: '../compo/a',
				alias: 'Some',
			});
		},
		'include' () {
			var imports = mask.parse(`
				import from 'compo/bar';
			`);
			eq_(imports.tagName, 'imports');

			var node = imports.nodes[0];
			has_(node, {
				tagName: 'import',
				path: 'compo/bar'
			});
		},
		'multiple sync resources' () {
			var imports = mask.parse(`
				import sync from 'foo';
				import from 'bar';
				import sync from 'qux';
			`);
			var nodes = imports.nodes;
			eq_(nodes.length, 3);
			has_(nodes[0], {path: 'foo', async: 'sync'});
			has_(nodes[1], {path: 'bar', async: null});
			has_(nodes[2], {path: 'qux', async: 'sync'});
		},
		'template with nodes' () {
			var imports = mask.parse(`
				import h4 as b_nest from 'nest-b';
				section {
					span > 'H4'
				}
			`);

			has_(imports.nodes[0], {
				tagName: 'import',
				path: 'nest-b',
				exports: [{
					name: 'h4',
					alias: 'b_nest'
				}]
			});
			has_(imports.nodes[1], {
				tagName: 'section'
			});
		},
		'modules with nested imports' () {
			var fragment = mask.parse(`
				module path='a.mask' {
					import from 'b.mask';
				}
				module path='b.mask' {
					import from 'c'
				}
			`);
			eq_(fragment.type, mask.Dom.FRAGMENT);
			eq_(fragment.nodes.length, 2);
			eq_(fragment.nodes[0].tagName, 'module')
			eq_(fragment.nodes[1].tagName, 'module')
		}
	},
	'serialize': {
		'all as alias' () {
			var tmpl = "import * as A from 'compo/bar';";
			var ast = mask.parse(tmpl);
			var str = mask.stringify(ast);

			eq_(tmpl, str);
		},
		'embed' () {
			var tmpl = "import from 'compo/bar';";
			var ast = mask.parse(tmpl);
			var str = mask.stringify(ast);

			eq_(tmpl, str);
		},
		'export' () {
			var tmpl = "import A from 'compo/bar';";
			var ast = mask.parse(tmpl);
			var str = mask.stringify(ast);

			eq_(tmpl, str);
		},
		'export as' () {
			var tmpl = "import A as B from 'compo/bar';";
			var ast = mask.parse(tmpl);
			var str = mask.stringify(ast);

			eq_(tmpl, str);
		},
		'exports' () {
			var tmpl = "import A, B from 'compo/bar';";
			var ast = mask.parse(tmpl);
			var str = mask.stringify(ast);

			eq_(tmpl, str);
		},
		'exports many' () {
			var tmpl = "import A as a, B, C as c from 'compo/bar.mask';";
			var ast = mask.parse(tmpl);
			var str = mask.stringify(ast);

			eq_(tmpl, str);
		}
	},
	'render': {
		'get all' () {
			return mask
				.renderAsync(`
					import * as foo1 from '/test/tmpl/modules/h4.mask';
					foo1;
				`)
				.done(dom => {
					$(dom).has_('h4');
				});
		},
		'get mask node' () {
			return mask
				.renderAsync(`
					import header as foo2 from '/test/tmpl/modules/header_content.mask';
					foo2;
				`)
				.done(dom => {
					$(dom).has_('header');
					$(dom).hasNot_('.content');
				})
		},
		'deep nesting' () {
			return mask
				.renderAsync(`
					import * as :nest from '/test/tmpl/modules/nest.mask';
					:nest;
				`)
				.pipe(dom => {

					return UTest.domtest(dom, `
						find ('section.a');
						find ('h4.b');
						find ('h4.a');
					`);
				});
		},
		'embed' () {
			return mask
				.renderAsync(`
					import from '/test/tmpl/modules/h4.mask';
				`)
				.done(dom => {
					$(dom)
						.has_('h4')
						.eq_('text', 'a');
				});
		},
		'errored' () {
			mask.on('error', assert.await());
			return mask
				.renderAsync(`
					import from '/none.mask';
				`)
				.then(dom => {
					mask.off('error');
					$(dom).has_('text', 'Load error: http://localhost:5777/utest/none.mask; Status: 404');
				});
		},
		'defines': {
			'should render simple defines' () {
				return mask
					.renderAsync(`
						import :menu, :footer from '/test/tmpl/modules/defines';

						h4 > :menu;
						div > :footer;
					`)
					.pipe(dom => {
						return UTest.domtest(dom, `
							filter('h4') > text Home;
							filter('div') > text Copyright;
						`);
					});
			},
			'should render define with inner `let` scope' () {
				mask.on('error', assert.avoid());
				return mask
					.renderAsync(`
						import FooScoped from '/test/tmpl/modules/defines_scopes';
						FooScoped;
					`)
					.then(dom => {
						mask.off('error');
						return UTest.domtest(dom, `
							find('.inner') > text Inner;
							find('menu') > text Home;
							find('footer') > text Copyright;
						`);
					});
			},
			'export nodes with iid defines' () {
				return mask
					.renderAsync(`
						import * as IiTest from '/test/tmpl/modules/ImmediateInvokeDefine';
						IiTest;
					`)
					.pipe(dom => {
						return UTest.domtest(dom, `
							filter('h4') > text Hello;
						`);
					});
			},
		},
		'scripts': {
			'load property' () {
				return mask
					.renderAsync(`
						import foo from '/test/tmpl/modules/data_foo.js';
						h4 > '~[foo.name]';
					`)
					.pipe(dom => {
						return UTest.domtest(dom, `
							filter('h4') > text Foo;
						`);
					});
			},
			'load full' () {
				return mask
					.renderAsync(`
						import * as x from '/test/tmpl/modules/data_foo.js';
						h4 > '~[x.foo.name]';
					`)
					.pipe(dom => {
						return UTest.domtest(dom, `
							filter('h4') > text Foo;
						`);
					});
			},
			'extending `define`' () {
				return mask
					.renderAsync(`
						import * as X from '/test/tmpl/modules/data_foo.js';
						define Bar extends X {
							h4 > '~[:$.foo.name]'
						}
						Bar;
					`)
					.pipe(dom => {
						return UTest.domtest(dom, `
							filter('h4') > text Foo;
						`);
					});
			},
			'extending `define` with imported handler' () {
				return mask
					.renderAsync(`
						import * as X from '/test/tmpl/modules/data_foo.js';
						define Bar extends X.foo {
							h4 > '~[:$.name]'
						}
						Bar;
					`)
					.pipe(dom => {
						return UTest.domtest(dom, `
							filter('h4') > text Foo;
						`);
					});
			},
		},

		'data':{
			'load json properties' () {
				return mask
					.renderAsync(`
						import baz from '/test/tmpl/modules/data_baz.json';
						h4 > '~[baz.name]';
					`)
					.pipe(dom => {
						return UTest.domtest(dom, `
							filter('h4') > text Baz;
						`);
					});
			},
		},

		'html': {
			'load html template' () {
				return mask
					.renderAsync(`
						import * as MyHeader from '/test/tmpl/modules/html/header.html';
						MyHeader;
					`)
					.pipe(dom => {
						return UTest.domtest(dom, `
							filter('header') > text Foo;
						`);
					});
			}
		},

		'packages': {
			'load package with embedded modules' () {
				return mask
					.renderAsync(`
						import * as Y from '/test/tmpl/modules/package';

						p > Y;
					`, { name: 'Foo' })
					.pipe(dom => {
						return UTest.domtest(dom, `
							filter('p') {
								has h4;
								text Foo;
							}
						`);
					});
			},

			'embed model template' () {
				return mask
					.renderAsync('import from "/test/tmpl/modules/model"')
					.pipe(dom => UTest.domtest(dom, `
						find ('h4') {
							text a;
						}
						find ('.foo') {
							text Foo;
						}
						find ('.baz') {
							text Baz;
						}
					`));
			},
			'repeat embedding' () {
				return mask
					.renderAsync('import from "/test/tmpl/modules/model"')
					.pipe(dom => UTest.domtest(dom, `
						find ('h4') {
							text a;
						}
						find ('.foo') {
							text Foo;
						}
						find ('.baz') {
							text Baz;
						}
					`));
			},
			'load model template' () {
				return mask
					.renderAsync('import * as X from "/test/tmpl/modules/model"; X;')
					.pipe(dom => UTest.domtest(dom, `
						find ('h4') {
							text a;
						}
						find ('.foo') {
							text Foo;
						}
						find ('.baz') {
							text Baz;
						}
					`));
			}
		},

		'plain': {
			'load text content by extension and explicit by type' () {
				return mask
					.renderAsync(`
						import * as baz from '/test/tmpl/modules/baz.txt';
						import * as bazIni from '/test/tmpl/modules/baz.ini' is text;
						h4 > '~baz';
						h3 > '~bazIni';
					`)
					.pipe(dom => {
						return UTest.domtest(dom, `
							filter('h4') > text ('Hello foo baz!');
							filter('h3') > text ('name=Baz');
						`);
					});
			},
		},

		//< packages

		'version' () {
			mask.Module.cfg('version', 'fooVer');
			var spy = sinon.spy(XMLHttpRequest.prototype, 'open');
			return mask
					.renderAsync('import from "/test/tmpl/modules/versioned";')
					.pipe(dom => {
						$(dom).has_('section');

						eq_(spy.callCount, 1);
						var args = spy.args[0];
						var url = args[1];

						has_(url, 'v=fooVer');
						XMLHttpRequest.prototype.open.restore();
						mask.Module.cfg('version', null);
					});
		},

		'resources without extensions' () {
			return mask
					.renderAsync(`
						import * as data from '/test/tmpl/modules/ext-less/myinfo' is json;
						import meta from '/test/tmpl/modules/ext-less/mymeta' is script;
						.json > '~[$scope.data.name]'
						.js > '~[$scope.meta.name]'

					`, { name: 'Foo' })
					.pipe(dom => {
						return UTest.domtest(dom, `
							find('.json') > text myinfo;
							find('.js')   > text mymeta;
						`);
					});
		}
	}, //< render

})

// vim: set ft=js: