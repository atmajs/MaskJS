UTest({
	'evaluate to empty array' () {
		[
			'[]',
			'	[ ]',
			' [		] ',
			`
				[

				]
			`
		]
		.forEach(x => {
			var arr = run(x);

			is_(arr, 'Array');
			eq_(arr.length, 0);
		})
	},
	'evaluate to an array with a number' () {
		[
			'[1]',
			'	[ 1 ]',
			' [		1] ',
			`
				[1

				]
			`
		]
		.forEach(x => {
			var arr = run(x);
			is_(arr, 'Array');
			eq_(arr.length, 1);
			eq_(arr[0], 1);
		})
	},
	'evaluate getters': {
		'simple correct getter' () {
			[
				'foo.bar.gaz',
				'foo["bar"].gaz',
				'foo["bar"]["gaz"]',
				`foo [ "bar" ] [ 'gaz' ]`,
				'foo .bar . gaz',
				'foo?.bar?.gaz',
				'foo ?.bar ?. gaz'				
			]
			.forEach(x => {
				var x = run(x, { foo: { bar: { gaz: 'abc' }} });
				eq_(x, 'abc');
			})
		}
	},
	'elvis opearotr': {
		$teardown () {
			Mask.off('warn');
		},
		'should silently return null' () {
			Mask.on('warn', assert.avoid());
			var x = run('foo?.bar.gaz', { });
			eq_(x, null);
		},
		'should drop warning' () {
			Mask.on('warn', assert.await(msg => {
				has_(msg.message, 'foo.bar.gaz');
			}));
			var x = run('foo.bar.gaz', { });
			eq_(x, null);
		}
	}
});
function run (expr, model) {
	return Mask.Utils.Expression.eval(expr, model);	
}
// vim: set ft=js: