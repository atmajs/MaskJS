// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../@utils/obj
//   ../../@utils/str
//   ../../@utils/is
//   ../../@utils/error
//   ../../@binding/exports
//   ../../@compo/exports
//   ../../@mask-j/jMask
//   ../../@compo/compo/Component
//   ../../@compo/model/IAttrDefinition
//   ../../@compo/deco/component_decorators
//   ../../@compo/model/IComponent

declare module 'mask' {
    import { _compound } from 'mask/--/projects/mask-compo/src/signal/compound'; 
     import { _toggle_single } from 'mask/--/projects/mask-compo/src/signal/toggle'; 
     import { _toggle_all } from 'mask/--/projects/mask-compo/src/signal/toggle'; 
     import { dom_addEventListener } from 'mask/--/projects/mask-compo/src/util/dom'; 
     import { PipeCtor } from 'mask/--/projects/mask-compo/src/compo/pipes'; 
     import { compo_attach } from 'mask/--/projects/mask-compo/src/util/compo'; 
     import { compo_attachDisposer } from 'mask/--/projects/mask-compo/src/util/compo'; 
     import { compo_ensureTemplate } from 'mask/--/projects/mask-compo/src/util/compo'; 
     import { compo_dispose } from 'mask/--/projects/mask-compo/src/util/compo'; 
     import { compo_child } from 'mask/--/projects/mask-compo/src/compo/find'; 
     import { compo_children } from 'mask/--/projects/mask-compo/src/compo/find'; 
     import { compo_closest } from 'mask/--/projects/mask-compo/src/compo/find'; 
     import { compo_findAll } from 'mask/--/projects/mask-compo/src/compo/find'; 
     import { compo_find } from 'mask/--/projects/mask-compo/src/compo/find'; 
     import { ICompo } from 'mask/--/projects/mask-compo/src/compo/Compo'; 
     import { deco_refCompo } from 'mask/--/projects/mask-compo/src/deco/component_decorators'; 
     import { deco_attr } from 'mask/--/projects/mask-compo/src/deco/component_decorators'; 
     import { deco_slot } from 'mask/--/projects/mask-compo/src/deco/component_decorators'; 
     import { ClassFactory } from 'mask/--/ref-utils/src/class'; 
     import { is_Array } from 'mask/--/ref-utils/src/is'; 
     import { _evaluateStatements } from 'mask/--/projects/expression/src/eval_statements'; 
     import { refs_extractVars } from 'mask/--/projects/expression/src/vars_helper'; 
     import { _evaluate } from 'mask/--/projects/expression/src/eval'; 
     import { _parse } from 'mask/--/projects/expression/src/parser'; 
     import { Component } from 'mask/dom/Component'; 
     import { _appendChild } from 'mask/dom/utils'; 
     import { INode } from 'mask/dom/INode'; 
     import { IDefineMethod } from 'mask/custom/tag'; 
     import { cache_get } from 'mask/feature/modules/cache'; 
     import { cache_clear } from 'mask/feature/modules/cache'; 
     import { tools_build } from 'mask/feature/modules/tools/build'; 
     import { tools_getDependencies } from 'mask/feature/modules/tools/dependencies'; 
     import { u_resolvePathFromImport } from 'mask/feature/modules/utils'; 
     import { u_resolveLocation } from 'mask/feature/modules/utils'; 
     import { m_cfg } from 'mask/feature/modules/config'; 
     import { type_getModuleType } from 'mask/feature/modules/types'; 
     import { type_get } from 'mask/feature/modules/types'; 
     import { type_isMask } from 'mask/feature/modules/types'; 
     import { i_createImport } from 'mask/feature/modules/Import/utils'; 
     import { m_registerModuleType } from 'mask/feature/modules/Module/utils'; 
     import { m_registerModule } from 'mask/feature/modules/Module/utils'; 
     import { m_createModule } from 'mask/feature/modules/Module/utils'; 
     import { Endpoint } from 'mask/feature/modules/class/Endpoint'; 
     import { fn_doNothing } from 'mask/--/ref-utils/src/fn'; 
     import { Statics } from 'mask/--/ref-utils/src/class'; 
     import { obj_getProperty, obj_setProperty, obj_extend } from '@utils/obj';
    import { str_dedent } from '@utils/str';
    import { is_Function, is_String, is_Object, is_Date } from '@utils/is';
    import { error_createClass } from '@utils/error';
    import { listeners_on, listeners_off } from 'mask/util/listeners';
    import { reporter_getNodeStack } from 'mask/util/reporters';
    import { customTag_register, customTag_registerFromTemplate, customTag_get, customTag_getAll, customStatement_register, customStatement_get, customAttr_register, customAttr_get, customUtil_register, customUtil_get } from 'mask/custom/exports';
    import { parser_ensureTemplateFunction, parser_parse, parser_parseHtml, mask_stringify, parser_ObjectLexer, parser_defineContentTag, parser_setInterpolationQuotes } from 'mask/parser/exports';
    import { mask_config } from 'mask/api/config';
    import { mask_run } from 'mask/feature/run';
    import { mask_merge } from 'mask/feature/merge';
    import { mask_optimize, mask_registerOptimizer } from 'mask/feature/optimize';
    
    
    import { obj_removeObserver, registerValidator, registerBinding } from '@binding/exports';
    import { Component } from '@compo/exports';
    import { jMask } from '@mask-j/jMask';
    import { renderer_clearCache, renderer_renderAsync, renderer_render } from 'mask/renderer/exports';
    /**
        * @namespace mask
        */
    export const Mask: {
            /**
                * Render the mask template to document fragment or single html node
                * @param {(string|MaskDom)} template - Mask string template or Mask Ast to render from.
                * @param {*} [model] - Model Object.
                * @param {Object} [ctx] - Context can store any additional information, that custom handler may need
                * @param {IAppendChild} [container]  - Container Html Node where template is rendered into
                * @param {Object} [controller] - Component that should own this template
                * @returns {(IAppendChild|Node|DocumentFragment)} container
                * @memberOf mask
                */
            render: typeof renderer_render;
            /**
                * Same to `mask.render` but returns the promise, which is resolved when all async components
                * are resolved, or is in resolved state, when all components are synchronous.
                * For the parameters doc @see {@link mask.render}
                * @returns {Promise} Fullfills with (`IAppendChild|Node|DocumentFragment`, `Component`)
                * @memberOf mask
                */
            renderAsync: typeof renderer_renderAsync;
            parse: typeof parser_parse;
            parseHtml: typeof parser_parseHtml;
            stringify: typeof mask_stringify;
            build: (node: any, model_: any, ctx: any, container_: any, ctr_: any, children_?: any) => any;
            buildSVG: (node: any, model_: any, ctx: any, container_: any, ctr_: any, children_?: any) => any;
            run: typeof mask_run;
            merge: typeof mask_merge;
            optimize: typeof mask_optimize;
            registerOptimizer: typeof mask_registerOptimizer;
            TreeWalker: {
                    walk: (root: any, fn: any) => any;
                    walkAsync: (root: any, fn: any, done: any) => void;
                    map: (root: any, fn: any) => any;
                    superpose: (rootA: any, rootB: any, fn: any) => any;
            };
            Module: {
                    ModuleMask: Statics<new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                            (mix?: any): void;
                            resolve(a?: any, b?: any, c?: any): any;
                            reject(error: any): any;
                            run(fn: any, ctx?: any): any;
                            all(promises: any): any;
                    } & {
                            type: any;
                            path: any;
                            location: any;
                            exports: any;
                            state: number;
                            constructor: (path: any, parent: any) => void;
                            loadModule: () => any;
                            doLoad: () => void;
                            complete_: (error: any, exports: any) => void;
                            onLoadSuccess_: (mix: any) => void;
                            onLoadError_: (error: any) => void;
                            load_: any;
                            preprocess_: any;
                            preprocessError_: any;
                            register: typeof fn_doNothing;
                            getExport: (property: any) => any;
                    }> & (new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                            (mix?: any): void;
                            resolve(a?: any, b?: any, c?: any): any;
                            reject(error: any): any;
                            run(fn: any, ctx?: any): any;
                            all(promises: any): any;
                    } & {
                            type: any;
                            path: any;
                            location: any;
                            exports: any;
                            state: number;
                            constructor: (path: any, parent: any) => void;
                            loadModule: () => any;
                            doLoad: () => void;
                            complete_: (error: any, exports: any) => void;
                            onLoadSuccess_: (mix: any) => void;
                            onLoadError_: (error: any) => void;
                            load_: any;
                            preprocess_: any;
                            preprocessError_: any;
                            register: typeof fn_doNothing;
                            getExport: (property: any) => any;
                    } & {
                            type: string;
                            scope: any;
                            source: any;
                            modules: any;
                            exports: any;
                            importItems: any;
                            load_: (path_: any) => any;
                            loadModule(): any;
                            preprocessError_(error: any, next: any): void;
                            preprocess_(mix: any, next: any): void;
                            getHandler(name: any): any;
                            queryHandler(selector: any): new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                                    scope: any;
                                    location: any;
                                    nodes: any;
                                    getHandler: (name: any) => any;
                            };
                            getExport(misc: any): any;
                    });
                    Endpoint: typeof Endpoint;
                    createModule: typeof m_createModule;
                    registerModule: typeof m_registerModule;
                    registerModuleType: typeof m_registerModuleType;
                    createImport: typeof i_createImport;
                    isMask: typeof type_isMask;
                    getType: typeof type_get;
                    getModuleType: typeof type_getModuleType;
                    cfg: typeof m_cfg;
                    resolveLocation: typeof u_resolveLocation;
                    resolvePath: typeof u_resolvePathFromImport;
                    getDependencies: typeof tools_getDependencies;
                    build: typeof tools_build;
                    clearCache: typeof cache_clear;
                    getCache: typeof cache_get;
                    reload: (path: any) => void;
                    types: any;
                    File: {
                            get: (path_: any) => any;
                            getScript: (path_: any) => any;
                            getStyle: (path_: any) => any;
                            getJson: (path_: any) => any;
                    };
            };
            File: {
                    get: (path_: any) => any;
                    getScript: (path_: any) => any;
                    getStyle: (path_: any) => any;
                    getJson: (path_: any) => any;
            };
            Di: {
                    resolve(Type: any): any;
                    setResolver(di: any): void;
                    deco: {
                            injectableClass(mix: any): any;
                    };
            };
            registerHandler: typeof customTag_register;
            registerFromTemplate: typeof customTag_registerFromTemplate;
            define: IDefineMethod;
            getHandler: typeof customTag_get;
            getHandlers: typeof customTag_getAll;
            registerStatement: typeof customStatement_register;
            getStatement: typeof customStatement_get;
            registerAttrHandler: typeof customAttr_register;
            getAttrHandler: typeof customAttr_get;
            registerUtil: typeof customUtil_register;
            getUtil: typeof customUtil_get;
            $utils: any;
            _: any;
            defineDecorator: (key: any, mix: any) => void;
            Dom: {
                    NODE: number;
                    TEXTNODE: number;
                    FRAGMENT: number;
                    COMPONENT: number;
                    CONTROLLER: number;
                    SET: number;
                    STATEMENT: number;
                    DECORATOR: number;
                    Node: new (...args: any[]) => INode;
                    TextNode: new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                            constructor: (text: any, parent: any) => void;
                            type: number;
                            content: any;
                            parent: any;
                            sourceIndex: number;
                    };
                    Fragment: new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                            type: number;
                            nodes: any;
                            appendChild: typeof _appendChild;
                            source: string;
                            filename: string;
                            syntax: string;
                            parent: any;
                    };
                    HtmlFragment: Statics<new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                            type: number;
                            nodes: any;
                            appendChild: typeof _appendChild;
                            source: string;
                            filename: string;
                            syntax: string;
                            parent: any;
                    }> & (new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                            type: number;
                            nodes: any;
                            appendChild: typeof _appendChild;
                            source: string;
                            filename: string;
                            syntax: string;
                            parent: any;
                    } & {
                            syntax: string;
                    });
                    Component: typeof Component;
                    DecoratorNode: new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
                            constructor: (expression: any, parent: any) => void;
                            __single: boolean;
                            expression: any;
                            parent: any;
                            sourceIndex: number;
                            type: number;
                            stringify: (stream: any) => void;
                    };
            };
            /**
                * Is present only in DEBUG (not minified) version
                * Evaluates script in masks library scope
                * @param {string} script
                */
            plugin(source: any): void;
            clearCache: typeof renderer_clearCache;
            Utils: {
                    Expression: {
                            'parse': typeof _parse;
                            'eval': typeof _evaluate;
                            'varRefs': typeof refs_extractVars;
                            'evalStatements': typeof _evaluateStatements;
                    };
                    ensureTmplFn: typeof parser_ensureTemplateFunction;
            };
            obj: {
                    get: typeof obj_getProperty;
                    set: typeof obj_setProperty;
                    extend: typeof obj_extend;
                    addObserver: (obj: any, property: string, cb: any) => void;
                    removeObserver: typeof obj_removeObserver;
            };
            str: {
                    dedent: typeof str_dedent;
            };
            is: {
                    Function: typeof is_Function;
                    String: typeof is_String;
                    ArrayLike: typeof is_Array;
                    Array: typeof is_Array;
                    Object: typeof is_Object;
                    Date: typeof is_Date;
                    NODE: boolean;
                    DOM: boolean;
            };
            class: {
                    create: ClassFactory;
                    createError: typeof error_createClass;
                    Deferred: {
                            (mix?: any): void;
                            resolve(a?: any, b?: any, c?: any): any;
                            reject(error: any): any;
                            run(fn: any, ctx?: any): any;
                            all(promises: any): any;
                    };
                    EventEmitter: () => void;
            };
            parser: {
                    ObjectLexer: typeof parser_ObjectLexer;
                    getStackTrace: typeof reporter_getNodeStack;
                    defineContentTag: typeof parser_defineContentTag;
            };
            log: {
                    info: any;
                    error: any;
                    errorWithNode: (mix: any, node: any) => void;
                    warn: any;
                    warnWithNode: (mix: any, node: any) => void;
            };
            on: typeof listeners_on;
            off: typeof listeners_off;
            delegateReload(): void;
            /**
                * Define interpolation quotes for the parser
                * Starting from 0.6.9 mask uses ~[] for string interpolation.
                * Old '#{}' was changed to '~[]', while template is already overloaded with #, { and } usage.
                * @param {string} start - Must contain 2 Characters
                * @param {string} end - Must contain 1 Character
                **/
            setInterpolationQuotes: typeof parser_setInterpolationQuotes;
            setCompoIndex(index: any): void;
            cfg: typeof mask_config;
            config: typeof mask_config;
            toHtml(dom: any): any;
            factory(compoName: any): void;
            injectable: (mix: any) => any;
            deco: {
                    slot: typeof deco_slot;
                    attr: typeof deco_attr;
                    refCompo: typeof deco_refCompo;
                    refElement: typeof deco_refCompo;
                    refQuery: typeof deco_refCompo;
                    inject: (mix: any) => any;
            };
            templates: {
                    get: (id: any) => any;
                    resolve: (node: any, id: any) => any;
                    register: (id: any, nodes: any) => void;
            };
            Validators: {
                    match: (match: any) => (str: any) => boolean;
                    unmatch: (unmatch: any) => (str: any) => boolean;
                    minLength: (min: any) => (str: any) => boolean;
                    maxLength: (max: any) => (str: any) => boolean;
                    check: (condition: any, node: any) => (str: any) => any;
            };
            registerValidator: typeof registerValidator;
            BindingProviders: {};
            registerBinding: typeof registerBinding;
            Compo: ICompo & {
                    create(...args: any[]): any;
                    createExt(Proto: any, args: any): any;
                    createClass(): never;
                    initialize(mix: any, model?: any, ctx?: any, container?: any, parent?: any): any;
                    find: typeof compo_find;
                    findAll: typeof compo_findAll; /**
                     * Render the mask template to document fragment or single html node
                     * @param {(string|MaskDom)} template - Mask string template or Mask Ast to render from.
                     * @param {*} [model] - Model Object.
                     * @param {Object} [ctx] - Context can store any additional information, that custom handler may need
                     * @param {IAppendChild} [container]  - Container Html Node where template is rendered into
                     * @param {Object} [controller] - Component that should own this template
                     * @returns {(IAppendChild|Node|DocumentFragment)} container
                     * @memberOf mask
                    closest: typeof compo_closest;
                    children: typeof compo_children;
                    child: typeof compo_child;
                    dispose: typeof compo_dispose;
                    ensureTemplate: typeof compo_ensureTemplate;
                    attachDisposer: typeof compo_attachDisposer;
                    attach: typeof compo_attach;
                    gc: {
                            using: (compo: any, x: any) => any;
                            on: (compo: any, emitter: any) => void;
                            subscribe: (compo: any, observable: any) => void;
                    };
                    element: {
                            getCompo: (el: any) => any;
                            getModel: (el: any) => any;
                    };
                    config: {
                            selectors: {
                                    '$'(compo: any, selector: any): any;
                                    'compo'(compo: any, selector: any): any;
                            };
                            setDOMLibrary(lib: any): void;
                            getDOMLibrary(): any;
                            eventDecorator(mix: any): void;
                    };
                    pipe: typeof PipeCtor;
                    resource(compo: any): any;
                    plugin(source: any): void;
                    Dom: {
                            addEventListener: typeof dom_addEventListener;
                    };
                    signal: {
                            toggle: typeof _toggle_all;
                            emitOut: (ctr: any, slot: any, sender: any, args: any) => void;
                            emitIn: (ctr: any, slot: any, sender?: any, args?: any) => void;
                            enable: (ctr: any, slot: any) => void;
                            disable: (ctr: any, slot: any) => void;
                    };
                    slot: {
                            toggle: typeof _toggle_single;
                            enable: (ctr: any, slot: any) => void;
                            disable: (ctr: any, slot: any) => void;
                            invoke: (ctr: any, slot: any, event: any, args: any) => any;
                            attach: typeof _compound;
                    };
                    DomLite: any;
                    pause: (compo: any, ctx: any) => () => void;
                    resume: (compo: any, ctx: any) => void;
                    await: (compo: Component) => any;
            };
            Component: typeof Component;
            jmask: typeof jMask;
            version: string;
            $: any;
            j: typeof jMask;
    };
}

export declare function _compound(ctr: any, slotExpression: any, cb: any): {
    slots: any;
    flags: any;
    cb: any;
    expression: any;
    constructor: (expression: any, cb: any) => void;
    signalDelegate: (name: any) => () => void;
    call: (this: any, name: any) => void;
    findSlot: (name: any) => any;
};

export declare function _toggle_all(ctr: any, slot: any, isActive: any): void;
export declare function _toggle_single(ctr: any, slot: any, isActive: any): void;

export declare function dom_addEventListener(el: any, event: any, fn: any, param?: string, ctr?: any): void;
export declare function node_tryDispose(node: any): void;
export declare function node_tryDisposeChildren(node: any): void;

declare function _removeController(ctr: any): void;
declare function _addController(ctr: any): void;
export declare class Pipe {
    name: string;
    constructor(name: any);
    emit(signal: any, a?: any, b?: any, c?: any): void;
}
export declare function PipeCtor(name: any): Pipe;
export declare namespace PipeCtor {
    var addController: typeof _addController;
    var removeController: typeof _removeController;
}
export declare const Pipes: {
    addController: typeof _addController;
    removeController: typeof _removeController;
    pipe: typeof PipeCtor;
};
export {};

import { Component } from '@compo/compo/Component';
export declare function compo_dispose(compo: any): void;
export declare function compo_detachChild(childCompo: any): void;
export declare function compo_ensureTemplate(compo: any): void;
export declare function compo_attachDisposer(compo: any, disposer: any): void;
export declare function compo_attach(compo: Component, name: string, fn: Function): void;
export declare function compo_removeElements(compo: any): void;
export declare function compo_cleanElements(compo: any): void;
export declare function compo_prepairAsync(dfr: any, compo: any, ctx: any): void;
export declare function compo_errored(compo: any, error: any): void;

export declare function compo_find(compo: any, selector: any): any;
export declare function compo_findAll(compo: any, selector: any): any;
export declare function compo_closest(compo: any, selector: any): any;
export declare function compo_children(compo: any, selector: any): any[];
export declare function compo_child(compo: any, selector: any): any;

import { CompoStatics } from 'mask/--/projects/mask-compo/src/compo/CompoStatics';
import { Component } from 'mask/--/projects/mask-compo/src/compo/Component';
export interface ICompo extends Component {
    (...args: any[]): new (...args: any[]) => Component;
    new (...args: any[]): Component;
}
export declare const Compo: ICompo & typeof CompoStatics;

import { IAttrDefinition } from '@compo/model/IAttrDefinition';
export declare function deco_slot(name?: string): (target: any, propertyKey: any, descriptor?: any) => any;
export declare function deco_attr(opts?: IAttrDefinition): (target: any, propertyKey: any, descriptor?: any) => void;
export declare function deco_refCompo(selector: string): (target: any, propertyKey: any, descriptor?: any) => void;
export declare function deco_refElement(selector: string): (target: any, propertyKey: any, descriptor?: any) => void;
export declare function deco_refQuery(selector: string): (target: any, propertyKey: any, descriptor?: any) => void;

export declare type Constructor<T = {}> = {
    new (...args: any[]): T;
};
export declare type Statics<T> = {
    [P in keyof T]: T[P];
};
export interface ClassFactory {
    <T1 extends Constructor | object, T2 extends Constructor | object = {}, T3 extends Constructor | object = {}, T4 extends Constructor | object = {}, T5 extends Constructor | object = {}>(mix1: T1, mix2?: T2, mix3?: T3, mix4?: T4, mix5?: T5): (T1 extends Constructor ? Statics<T1> : {}) & (T2 extends Constructor ? Statics<T2> : {}) & (T3 extends Constructor ? Statics<T3> : {}) & (T4 extends Constructor ? Statics<T4> : {}) & (T5 extends Constructor ? Statics<T5> : {}) & (new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => (T1 extends Constructor ? InstanceType<T1> : T1) & (T2 extends Constructor ? InstanceType<T2> : T2) & (T3 extends Constructor ? InstanceType<T3> : T3) & (T4 extends Constructor ? InstanceType<T4> : T4) & (T5 extends Constructor ? InstanceType<T5> : T5));
}
/**
  * create([...Base], Proto)
  * Base: Function | Object
  * Proto: Object {
  *    constructor: ?Function
  *    ...
  */
export declare const class_create: ClassFactory;
export declare const class_createEx: (a: any, b?: any, c?: any, d?: any, e?: any, f?: any, g?: any, h?: any) => any;

export declare function is_Function(x: any): x is Function;
export declare function is_Object(x: any): x is any;
export declare function is_Array<T = any>(arr: any): arr is T[];
export declare const is_ArrayLike: typeof is_Array;
export declare function is_String(x: any): x is string;
export declare function is_notEmptyString(x: any): boolean;
export declare function is_rawObject(x: any): x is object;
export declare function is_Date(x: any): x is Date;
export declare function is_PromiseLike<T = any>(x: any): x is PromiseLike<T>;
export declare function is_Observable(x: any): boolean;
export declare const is_DOM: boolean;
export declare const is_NODE: boolean;

export declare function _evaluateStatements(expr: any, model?: any, ctx?: any, ctr?: any, node?: any): any[];

/**
  * extract symbol references
  * ~[:user.name + 'px'] -> 'user.name'
  * ~[:someFn(varName) + user.name] -> ['varName', 'user.name']
  *
  * ~[:someFn().user.name] -> {accessor: (Accessor AST function call) , ref: 'user.name'}
  */
export declare function refs_extractVars(mix: any, model?: any, ctx?: any, ctr?: any): any;

export declare function _evaluate(mix: any, model?: any, ctx?: any, ctr?: any, node?: any): any;
export declare function _evaluateAst(ast: any, model: any, ctx: any, ctr: any, preResults?: any): any;

export declare function _parse(expr: any, earlyExit?: any, node?: any): any;
export declare function parser_getRef(): any;
export declare function parser_getDirective(code: any): "|" | "^" | "-" | "+" | "/" | "*" | "%" | "||" | "&&" | "!" | "==" | "===" | "!=" | "!==" | ">" | ">=" | "<" | "<=" | "->" | ">>" | "&" | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 33 | 34;
export declare function ast_append(current: any, next: any): any;

declare module 'mask/dom/Component' {
    export function Component(compoName?: any, parent?: any, controller?: any): void;
}

declare module 'mask/dom/utils' {
    export function _appendChild(el: any): void;
}

declare module 'mask/dom/INode' {
    export interface INode {
        __single: boolean;
        type: number;
        tagName: string;
        attr: {
            [name: string]: any;
        };
        props: {
            [name: string]: any;
        };
        expression: string;
        nodes: INode[];
        nextSibling: INode;
        parent: INode;
        sourceIndex: number;
        decorators: any;
        stringify(stream: any): any;
        appendChild(el: any): any;
        constructor(tagName: string, parent?: INode): any;
    }
}

declare module 'mask/custom/tag' {
    /**
        * Get Components constructor from the global repository or the scope
        * @param {string} name
        * @param {object} [component] - pass a component to look in its scope
        * @returns {IComponent}
        * @memberOf mask
        * @method getHandler
        */
    export function customTag_get(name: any, ctr?: any): any;
    /**
        * Get all components constructors from the global repository and/or the scope
        * @param {object} [component] - pass a component to look also in its scope
        * @returns {object} All components in an object `{name: Ctor}`
        * @memberOf mask
        * @method getHandlers
        */
    export function customTag_getAll(ctr?: any): any;
    /**
        * Register a component
        * @param {string} name
        * @param {object|IComponent} component
        * @param {object} component - Component static definition
        * @param {IComponent} component - Components constructor
        * @returns {void}
        * @memberOf mask
        * @method registerHandler
        */
    export function customTag_register(mix: any, Handler: any): void;
    /**
        * Register components from a template
        * @param {string} template - Mask template
        * @param {object|IComponent} [component] - Register in the components scope
        * @param {string} [path] - Optionally define the path for the template
        * @returns {Promise} - Fullfills when all submodules are resolved and components are registerd
        * @memberOf mask
        * @method registerFromTemplate
        */
    export function customTag_registerFromTemplate(mix: any, Ctr?: any, path?: any): PromiseLike<void>;
    /**
        * Register a component
        * @param {object|IComponent} scopedComponent - Use components scope
        * @param {string} name - Name of the component
        * @param {object|IComponent} component - Components definition
        * @returns {void}
        * @memberOf mask
        * @method registerScoped
        */
    export function customTag_registerScoped(Ctx: any, name: any, Handler: any): void;
    export interface IDefineMethod {
            (template: string): any;
            (scopeName: string, template: string): any;
            (scopeCompo: Function, template: string): any;
            (compoName: Function, Ctor: Function | any): any;
            (scopeCompo: Function, compoName: Function, Ctor: Function | any): any;
            (scopeName: string, compoName: Function, Ctor: Function | any): any;
            (mix: string | Function, mix2?: string | Function | any, mix3?: string | Function | any): any;
    }
    /**
        * Universal component definition, which covers all the cases: simple, scoped, template
        * - 1. (template)
        * - 2. (scopedCompoName, template)
        * - 3. (scopedCtr, template)
        * - 4. (name, Ctor)
        * - 5. (scopedCtr, name, Ctor)
        * - 6. (scopedCompoName, name, Ctor)
        * @returns {void|Promise}
        * @memberOf mask
        * @method define
        */
    export const customTag_define: IDefineMethod;
    export function customTag_registerResolver(name: any): void;
    export function customTag_Compo_getHandler(name: any): any;
    export const customTag_Base: {
            async: boolean;
            attr: any;
            await: any;
            compoName: any;
            components: any;
            expression: any;
            ID: any;
            meta: any;
            node: any;
            model: any;
            nodes: any;
            parent: any;
            render: any;
            renderEnd: any;
            renderStart: any;
            tagName: any;
            type: any;
    };
    export const customTag_Resolver: (node: any, model: any, ctx: any, container: any, ctr: any) => any;
}

declare module 'mask/feature/modules/cache' {
    import { Endpoint } from 'mask/feature/modules/class/Endpoint';
    export function cache_get(endpoint: Endpoint): any;
    export function cache_set(endpoint: Endpoint, module: any): any;
    export function cache_clear(path?: any): void;
    export function cache_toMap(): {};
}

declare module 'mask/feature/modules/tools/build' {
    export function tools_build(template: any, path: any, opts_?: any): any;
}

declare module 'mask/feature/modules/tools/dependencies' {
    export function tools_getDependencies(template: any, path: any, opts_?: {
        deep?: boolean;
        flattern?: boolean;
    }): any;
}

declare module 'mask/feature/modules/utils' {
    export function u_resolveLocation(ctx: any, ctr?: any, module?: any): any;
    export function u_setOption(options: any, key: any, val: any): any;
    export function u_resolveBase(): any;
    export function u_resolvePath(path: any, ctx: any, ctr: any, module: any): any;
    export function u_resolvePathFromImport(node: any, ctx?: any, ctr?: any, module?: any, makeAbs?: any): any;
    export function u_handler_getDelegate(compoName: any, compo: any, next: any): (name: any) => any;
    export function u_isNpmPath(path: any): boolean;
    export function u_resolveNpmPath(contentType: any, path: any, parentLocation: any, cb: any): void;
}

declare module 'mask/feature/modules/config' {
    export function m_cfg(mix: any, val: any): any;
}

declare module 'mask/feature/modules/types' {
    import { Endpoint } from 'mask/feature/modules/class/Endpoint';
    export const _typeMappings: {
        script: string;
        style: string;
        data: string;
        mask: string;
        html: string;
        js: string;
        ts: string;
        es6: string;
        coffee: string;
        css: string;
        scss: string;
        sass: string;
        less: string;
        json: string;
        yml: string;
        txt: string;
        text: string;
        load: string;
    };
    export function type_isMask(endpoint: Endpoint): boolean;
    export function type_get(endpoint: Endpoint): any;
    export function type_getModuleType(endpoint: Endpoint): any;
}

declare module 'mask/feature/modules/Import/utils' {
    export function i_createImport(node: any, ctx: any, ctr: any, module?: any): any;
}

declare module 'mask/feature/modules/Module/utils' {
    export function m_createModule(node: any, ctx: any, ctr: any, parent?: any): any;
    export function m_registerModule(mix: any, endpoint: any, ctx?: any, ctr?: any, parent?: any): any;
    export function m_registerModuleType(baseModuleType: any, newType: any, mix: any): void;
}

declare module 'mask/feature/modules/class/Endpoint' {
    export class Endpoint {
        path: string;
        contentType: string;
        moduleType: string;
        constructor(path: any, contentType?: any, moduleType?: any);
    }
}

export declare function fn_proxy(fn: any, ctx: any): () => any;
export declare function fn_apply(fn: any, ctx: any, args: any): any;
export declare function fn_doNothing(): boolean;
export declare function fn_createByPattern(definitions: any, ctx?: any): () => any;

declare module 'mask/util/listeners' {
    /**
        * Bind listeners to some system events:
        * - `error` Any parser or render error
        * - `compoCreated` Each time new component is created
        * - `config` Each time configuration is changed via `config` fn
        * @param {string} eveny
        * @param {function} cb
        * @memberOf mask
        * @method on
        */
    export function listeners_on(event: any, fn: any): void;
    /**
        * Unbind listener
        * - `error` Any parser or render error
        * - `compoCreated` Each time new component is created
        * @param {string} eveny
        * @param {function} [cb]
        * @memberOf mask
        * @method on
        */
    export function listeners_off(event: any, fn?: any): void;
    export function listeners_emit(event: any, v1?: any, v2?: any, v3?: any, v4?: any, v5?: any): boolean;
}

declare module 'mask/util/reporters' {
    export const log: any;
    export const log_warn: any;
    export const log_error: any;
    export function throw_(error: any): void;
    export const error_: (arg1?: any, arg2?: any, arg3?: any) => void;
    export const error_withSource: (mix: any, source: any, index: any, file: any) => void;
    export const error_withNode: (mix: any, node: any) => void;
    export const error_withCompo: (mix: any, compo: any) => void;
    export const warn_: (arg1?: any, arg2?: any, arg3?: any) => void;
    export const warn_withSource: (mix: any, source: any, index: any, file: any) => void;
    export const warn_withNode: (mix: any, node: any) => void;
    export const warn_withCompo: (mix: any, compo: any) => void;
    export const parser_error: (str: any, source: any, index?: any, token?: any, state?: any, file?: any) => void;
    export const parser_warn: (str: any, source: any, index?: any, token?: any, state?: any, file?: any) => void;
    export function reporter_createErrorNode(message: any): {
        type: number;
        tagName: string;
        attr: {
            class: string;
            style: string;
        };
        nodes: {
            type: number;
            content: any;
        }[];
    };
    export function reporter_getNodeStack(node: any): string;
    export function reporter_deprecated(id: any, message: any): void;
}

declare module 'mask/custom/exports' {
    export { custom_optimize } from 'mask/custom/optimize';
    export { custom_Utils, custom_Statements, custom_Attributes, custom_Tags, custom_Tags_global, custom_Tags_defs, custom_Parsers, custom_Parsers_Transform, custom_Optimizers } from 'mask/custom/repositories';
    export { customAttr_register, customAttr_get } from 'mask/custom/attribute';
    export { customTag_get, customTag_getAll, customTag_register, customTag_registerScoped, customTag_registerFromTemplate, customTag_registerResolver, customTag_Resolver, customTag_Compo_getHandler, customTag_define, customTag_Base } from 'mask/custom/tag';
    export { customUtil_get, customUtil_$utils, customUtil_register } from 'mask/custom/util';
    export { customStatement_register, customStatement_get } from 'mask/custom/statement';
}

declare module 'mask/parser/exports' {
    export { parser_parse } from 'mask/parser/mask/parser';
    export { parser_parseHtml } from 'mask/parser/html/parser';
    export { parser_parseAttr, parser_parseAttrObject } from 'mask/parser/mask/partials/attributes';
    export { parser_parseLiteral } from 'mask/parser/mask/partials/literal';
    export { parser_setInterpolationQuotes } from 'mask/parser/const';
    export { parser_ensureTemplateFunction } from 'mask/parser/interpolation';
    export { parser_cleanObject } from 'mask/parser/utils';
    export { parser_ObjectLexer } from 'mask/parser/object/ObjectLexer';
    export { parser_defineContentTag } from 'mask/parser/config';
    export { mask_stringify, mask_stringifyAttr } from 'mask/parser/mask/stringify';
    export { Templates } from 'mask/parser/Templates';
    export { cursor_groupEnd } from 'mask/parser/cursor';
}

declare module 'mask/api/config' {
    /**
        * Configuration Options
        * @type {object}
        * @typedef Configuration
        */
    export const __cfg: {
            /**
                * Relevant for NodeJS only. Disable/Enable compo caching.
                * @default true
                */
            allowCache: boolean;
            /**
                * Style and Script preprocessors
                * @type {object}
                * @memberOf Configuration
                */
            preprocessor: {
                    /**
                        * Transform style before using in `style` tag
                        * @type {function}
                        * @param {string} style
                        * @returns {string}
                        * @memberOf Configuration
                        */
                    style: any;
                    /**
                        * Transform script before using in `function,script,event,slot` tags
                        * @type {function}
                        * @param {string} source
                        * @returns {string}
                        * @memberOf Configuration
                        */
                    script: any;
            };
            /**
                * Base path for modules
                * @default null
                * @memberOf Configuration
                */
            base: any;
            modules: string;
            /**
                * Define custom function for getting files content by path
                * @param {string} path
                * @returns {Promise}
                * @memberOf Configuration
                */
            getFile: any;
            /**
                * Define custom function for getting script
                * @param {string} path
                * @returns {Promise} Fulfill with exports
                * @memberOf Configuration
                */
            getScript: any;
            /**
                * Define custom function for getting styles
                * @param {string} path
                * @returns {Promise} Fulfill with exports
                * @memberOf Configuration
                */
            getStyle: any;
            /**
                * Define custom function for getting jsons
                * @param {string} path
                * @returns {Promise} Fulfill with exports
                * @memberOf Configuration
                */
            getData: any;
            getJson: any;
            /**
                * Define custom function to build/combine styles
                * @param {string} path
                * @param {object} options
                * @returns {Promise} Fulfill with {string} content
                * @memberOf Configuration
                */
            buildStyle: any;
            /**
                * Define custom function to build/combine scripts
                * @param {string} path
                * @param {object} options
                * @returns {Promise} Fulfill with {string} content
                * @memberOf Configuration
                */
            buildScript: any;
            /**
                * Define custom function to build/combine jsons
                * @param {string} path
                * @param {object} options
                * @returns {Promise} Fulfill with {string} content
                * @memberOf Configuration
                */
            buildData: any;
    };
    /**
        * Get or Set configuration settings
        * - 1 `(name)`
        * - 2 `(name, value)`
        * - 3 `(object)`
        * @see @{link MaskOptions} for all options
        * @memberOf mask
        * @method config
        */
    export function mask_config(a?: any, b?: any, c?: any): any;
}

declare module 'mask/feature/run' {
    /**
      * Find all `<script type="text/mask" data-run='true'>` blocks in the page
      * and render each block into the parents container.
      *
      * The function is automatically renders the blocks
      * `<script type="text/mask" data-run='auto'>` on `DOMContentLoaded` event
      * @returns {object} Root component
      * @memberOf mask
      * @method run
     */
    export function mask_run(): any;
}

declare module 'mask/feature/merge' {
    /**
      * Join two Mask templates or DOM trees
      * @param {(string|MaskNode)} a - first template
      * @param {(string|MaskNode)} b - second template
      * @param {(MaskNode|Component)} [owner]
      * @param {object} [opts]
      * @param {bool} [opts.extending=false] - Clean the merged tree from all unused placeholders
      * @param {obj} [stats] - Output holder, if merge info is requred
      * @returns {MaskNode} New joined Mask DOM tree
      * @memberOf mask
      * @method merge
      */
    export function mask_merge(a: any, b: any, owner?: any, opts?: any, stats?: any): any;
}

declare module 'mask/feature/optimize' {
    /**
        * Run all registerd optimizers recursively on the nodes
        * @param {MaskNode} node
        * @param {function} onComplete
        * @param {mask.optimize~onComplete} done
        */
    export function mask_optimize(dom: any, done: any): void;
    /**
        * Register custom optimizer for a node name
        * @param {string} tagName - Node name
        * @param {function} visitor - Used for @see {@link mask.TreeWalker.walkSync}
        */
    export function mask_registerOptimizer(tagName: any, fn: any): void;
}

declare module 'mask/renderer/exports' {
    /**
        * Render the mask template to document fragment or single html node
        * @param {(string|MaskDom)} template - Mask string template or Mask Ast to render from.
        * @param {*} [model] - Model Object.
        * @param {Object} [ctx] - Context can store any additional information, that custom handler may need
        * @param {IAppendChild} [container]  - Container Html Node where template is rendered into
        * @param {Object} [controller] - Component that should own this template
        * @returns {(IAppendChild|Node|DocumentFragment)} container
        * @memberOf mask
        */
    export function renderer_render<T extends HTMLElement>(mix: any, model?: any, ctx?: any, container?: any, controller?: any): T;
    /**
        * Same to `mask.render` but returns the promise, which is resolved when all async components
        * are resolved, or is in resolved state, when all components are synchronous.
        * For the parameters doc @see {@link mask.render}
        * @returns {Promise} Fullfills with (`IAppendChild|Node|DocumentFragment`, `Component`)
        * @memberOf mask
        */
    export function renderer_renderAsync(template: any, model?: any, ctx?: any, container?: any, ctr?: any): PromiseLike<HTMLElement>;
    export function renderer_clearCache(key: any): void;
}

import { _compound } from 'mask/--/projects/mask-compo/src/signal/compound'; 
 import { _toggle_single } from 'mask/--/projects/mask-compo/src/signal/toggle'; 
 import { _toggle_all } from 'mask/--/projects/mask-compo/src/signal/toggle'; 
 import { PipeCtor } from 'mask/--/projects/mask-compo/src/compo/pipes'; 
 import { compo_dispose, compo_ensureTemplate, compo_attachDisposer, compo_attach } from 'mask/--/projects/mask-compo/src/util/compo';
import { dom_addEventListener } from 'mask/--/projects/mask-compo/src/util/dom';
import { compo_find, compo_findAll, compo_closest, compo_children, compo_child } from 'mask/--/projects/mask-compo/src/compo/find';
import { Component } from 'mask/--/projects/mask-compo/src/compo/Component';
export declare const CompoStatics: {
        create(...args: any[]): any;
        createExt(Proto: any, args: any): any;
        createClass(): never;
        initialize(mix: any, model?: any, ctx?: any, container?: any, parent?: any): any;
        find: typeof compo_find;
        findAll: typeof compo_findAll;
        closest: typeof compo_closest;
        children: typeof compo_children;
        child: typeof compo_child;
        dispose: typeof compo_dispose;
        ensureTemplate: typeof compo_ensureTemplate;
        attachDisposer: typeof compo_attachDisposer;
        attach: typeof compo_attach;
        gc: {
                using: (compo: any, x: any) => any;
                on: (compo: any, emitter: any) => void;
                subscribe: (compo: any, observable: any) => void;
        };
        element: {
                getCompo: (el: any) => any;
                getModel: (el: any) => any;
        };
        config: {
                selectors: {
                        '$'(compo: any, selector: any): any;
                        'compo'(compo: any, selector: any): any;
                };
                setDOMLibrary(lib: any): void;
                getDOMLibrary(): any;
                eventDecorator(mix: any): void;
        };
        pipe: typeof PipeCtor;
        resource(compo: any): any;
        plugin(source: any): void;
        Dom: {
                addEventListener: typeof dom_addEventListener;
        };
        signal: {
                toggle: typeof _toggle_all;
                emitOut: (ctr: any, slot: any, sender: any, args: any) => void;
                emitIn: (ctr: any, slot: any, sender?: any, args?: any) => void;
                enable: (ctr: any, slot: any) => void;
                disable: (ctr: any, slot: any) => void;
        };
        slot: {
                toggle: typeof _toggle_single;
                enable: (ctr: any, slot: any) => void;
                disable: (ctr: any, slot: any) => void;
                invoke: (ctr: any, slot: any, event: any, args: any) => any;
                attach: typeof _compound;
        };
        DomLite: any;
        pause: (compo: any, ctx: any) => () => void;
        resume: (compo: any, ctx: any) => void;
        await: (compo: Component) => any;
};

import { _compound } from 'mask/--/projects/mask-compo/src/signal/compound'; 
 import { _toggle_single } from 'mask/--/projects/mask-compo/src/signal/toggle'; 
 import { _toggle_all } from 'mask/--/projects/mask-compo/src/signal/toggle'; 
 import { dom_addEventListener } from 'mask/--/projects/mask-compo/src/util/dom'; 
 import { PipeCtor } from 'mask/--/projects/mask-compo/src/compo/pipes'; 
 import { compo_attach } from 'mask/--/projects/mask-compo/src/util/compo'; 
 import { compo_attachDisposer } from 'mask/--/projects/mask-compo/src/util/compo'; 
 import { compo_ensureTemplate } from 'mask/--/projects/mask-compo/src/util/compo'; 
 import { compo_dispose } from 'mask/--/projects/mask-compo/src/util/compo'; 
 import { compo_child } from 'mask/--/projects/mask-compo/src/compo/find'; 
 import { compo_children } from 'mask/--/projects/mask-compo/src/compo/find'; 
 import { compo_closest } from 'mask/--/projects/mask-compo/src/compo/find'; 
 import { compo_findAll } from 'mask/--/projects/mask-compo/src/compo/find'; 
 import { compo_find } from 'mask/--/projects/mask-compo/src/compo/find'; 
 import { deco_slot, deco_attr, deco_refCompo, deco_refElement, deco_refQuery } from '@compo/deco/component_decorators';
import { IComponent } from '@compo/model/IComponent';
declare const Component_base: new (arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, arg6?: any, arg7?: any) => {
        type: number;
        __constructed: boolean;
        __resource: any;
        __frame: any;
        __tweens: any;
        ID: any;
        tagName: any;
        compoName: any;
        node: any;
        nodes: any;
        components: any;
        expression: any;
        attr: any;
        model: any;
        scope: any;
        slots: any;
        pipes: any;
        compos: any;
        events: any;
        hotkeys: any;
        async: boolean;
        await: any;
        resume: any;
        meta: {
                mode: null;
                modelMode: null;
                attributes: null;
                properties: null;
                arguments: null;
                template: null;
                serializeNodes: null;
                readAttributes: null;
                readProperties: null;
                readArguments: null;
                refs: null;
        };
        getAttribute<T = any>(key: string): T;
        setAttribute(key: string, val: any): void;
        onAttributeSet: any;
        onRenderStart: any;
        onRenderStartClient: any;
        onRenderEnd: any;
        onRenderEndServer: any;
        onEnterFrame: any;
        render: any;
        renderStart(model: any, ctx: any, container: any): void;
        renderStartClient(model: any, ctx: any, container: any): void;
        renderEnd(elements: any, model: any, ctx: any, container: any): void;
        appendTo(el: any): any;
        append(template: any, model: any, selector: any): any;
        find(selector: any): any;
        findAll(selector: any): any;
        closest(selector: any): any;
        on(): any;
        remove(): any;
        slotState(slotName: any, isActive: any): any;
        signalState(signalName: any, isActive: any): any;
        emitOut(signalName: any, a1: any, a2: any, a3: any, a4: any): any;
        emitIn(signalName: any, a1: any, a2: any, a3: any, a4: any): any;
        $scope(path: any): any;
        $eval(expr: any, model: any, ctx: any): any;
        attach(name: any, fn: any): void;
        serializeState(): {
                scope: any;
        };
        deserializeState(bundle: any): void;
};
export declare class Component extends Component_base implements IComponent {
        constructor();
        static create: (...args: any[]) => any;
        static createExt: (Proto: any, args: any) => any;
        static createClass: () => never;
        static initialize: (mix: any, model?: any, ctx?: any, container?: any, parent?: any) => any;
        static find: typeof compo_find;
        static findAll: typeof compo_findAll;
        static closest: typeof compo_closest;
        static children: typeof compo_children;
        static child: typeof compo_child;
        static dispose: typeof compo_dispose;
        static ensureTemplate: typeof compo_ensureTemplate;
        static attachDisposer: typeof compo_attachDisposer;
        static attach: typeof compo_attach;
        static gc: {
                using: (compo: any, x: any) => any;
                on: (compo: any, emitter: any) => void;
                subscribe: (compo: any, observable: any) => void;
        };
        static element: {
                getCompo: (el: any) => any;
                getModel: (el: any) => any;
        };
        static config: {
                selectors: {
                        '$'(compo: any, selector: any): any;
                        'compo'(compo: any, selector: any): any;
                };
                setDOMLibrary(lib: any): void;
                getDOMLibrary(): any;
                eventDecorator(mix: any): void;
        };
        static pipe: typeof PipeCtor;
        static resource: (compo: any) => any;
        static plugin: (source: any) => void;
        static Dom: {
                addEventListener: typeof dom_addEventListener;
        };
        static signal: {
                toggle: typeof _toggle_all;
                emitOut: (ctr: any, slot: any, sender: any, args: any) => void;
                emitIn: (ctr: any, slot: any, sender?: any, args?: any) => void;
                enable: (ctr: any, slot: any) => void;
                disable: (ctr: any, slot: any) => void;
        };
        static slot: {
                toggle: typeof _toggle_single;
                enable: (ctr: any, slot: any) => void;
                disable: (ctr: any, slot: any) => void;
                invoke: (ctr: any, slot: any, event: any, args: any) => any;
                attach: typeof _compound;
        };
        static DomLite: any;
        static pause: (compo: any, ctx: any) => () => void;
        static resume: (compo: any, ctx: any) => void;
        static await: (compo: Component) => any;
        static deco: {
                slot: typeof deco_slot;
                attr: typeof deco_attr;
                refCompo: typeof deco_refCompo;
                refElement: typeof deco_refElement;
                refQuery: typeof deco_refQuery;
        };
}
export {};

declare module 'mask/custom/optimize' {
    export function custom_optimize(): void;
}

declare module 'mask/custom/repositories' {
    export const custom_Utils: {};
    export const custom_Optimizers: {};
    export const custom_Statements: {};
    export const custom_Attributes: any;
    export const custom_Tags: any;
    export const custom_Tags_global: any;
    export const custom_Parsers: any;
    export const custom_Parsers_Transform: any;
    export const custom_Tags_defs: {};
}

declare module 'mask/custom/attribute' {
    /**
        * Register an attribute handler. Any changes can be made to:
        * - maskNode's template
        * - current element value
        * - controller
        * - model
        * Note: Attribute wont be set to an element.
        * @param {string} name - Attribute name to handle
        * @param {string} [mode] - Render mode `client|server|both`
        * @param {AttributeHandler} handler
        * @returns {void}
        * @memberOf mask
        * @method registerAttrHandler
        */
    export function customAttr_register(attrName: any, mix: any, Handler?: any): void;
    /**
        * Get attribute  handler
        * @param {string} name
        * @returns {AttributeHandler}
        * @memberOf mask
        * @method getAttrHandler
        */
    export function customAttr_get(attrName: any): any;
}

declare module 'mask/custom/util' {
    /**
        * Utils Repository
        * @param {string} name
        * @param {(IUtilHandler|UtilHandler)} handler
        * @memberOf mask
        * @name _
        * @category Mask Util
        */
    export const customUtil_$utils: any;
    /**
        * Register Util Handler. Template Example: `'~[myUtil: value]'`
        * @param {string} name
        * @param {(mask._.IUtilHandler|mask._.FUtilHandler)} handler
        * @memberOf mask
        * @method getUtil
        * @category Mask Util
        */
    export function customUtil_register(name: any, mix: any): void;
    /**
        * Get the Util Handler
        * @param {string} name
        * @memberOf mask
        * @method registerUtil
        * @category Mask Util
        */
    export function customUtil_get(name: any): any;
}

declare module 'mask/custom/statement' {
    /**
        * Register a statement handler
        * @param {string} name - Tag name to handle
        * @param StatementHandler} handler
        * @memberOf mask
        * @method registerStatement
        */
    export function customStatement_register(name: any, handler: any): void;
    /**
        * Get statement handler
        * @param {string} name
        * @returns {StatementHandler}
        * @memberOf mask
        * @method getStatement
        */
    export function customStatement_get(name: any): any;
}

declare module 'mask/parser/mask/parser' {
    /**
      * Parse **Mask** template to the AST tree
      * @param {string} template - Mask Template
      * @returns {MaskNode}
      * @memberOf mask
      * @method parse
      */
    export function parser_parse(template: any, filename?: any): any;
}

declare module 'mask/parser/html/parser' {
    /**
      * Parse **Html** template to the AST tree
      * @param {string} template - Html Template
      * @returns {MaskNode}
      * @memberOf mask
      * @method parseHtml
      */
    export function parser_parseHtml(str: any): any;
    export function parser_parseHtmlPartial(str: any, index: any, exitEarly: any): any[];
}

declare module 'mask/parser/mask/partials/attributes' {
    export function parser_parseAttr(str: any, start: any, end: any): {};
    export function parser_parseAttrObject(str: any, i: any, imax: any, attr: any): any;
}

declare module 'mask/parser/mask/partials/literal' {
    export function parser_parseLiteral(str: any, start: any, imax: any): any[];
}

declare module 'mask/parser/const' {
    export var interp_START: string;
    export var interp_OPEN: string;
    export var interp_CLOSE: string;
    export var interp_code_START: number;
    export var interp_code_OPEN: number;
    export var interp_code_CLOSE: number;
    export var go_tag: number;
    export var go_up: number;
    export var go_attrVal: number;
    export var go_propVal: number;
    export var go_attrHeadVal: number;
    export var state_tag: number;
    export var state_attr: number;
    export var state_prop: number;
    export var state_literal: number;
    export function parser_setInterpolationQuotes(start: any, end: any): void;
}

declare module 'mask/parser/interpolation' {
    export function parser_ensureTemplateFunction(template: string): string | ((type: any, model: any, ctx: any, element: any, ctr: any, name?: any, node?: any) => any);
}

declare module 'mask/parser/utils' {
    export function parser_cleanObject(mix: any): any;
}

declare module 'mask/parser/object/ObjectLexer' {
    export function parser_ObjectLexer(pattern: any, a?: any, b?: any, c?: any, d?: any, f?: any): any;
}

declare module 'mask/parser/config' {
    export const parser_cfg_ContentTags: {
        script: number;
        style: number;
        template: number;
        markdown: number;
    };
    export function parser_defineContentTag(name: any): void;
}

declare module 'mask/parser/mask/stringify' {
    /**
      * Serialize Mask AST to the Mask string (@analog to `JSON.stringify`)
      * @param {MaskNode} node - MaskNode
      * @param {(object|number)} [opts] - Indent count option or an object with options
      * @param {number} [opts.indent=0] - Indent count, `0` for minimization
      * @param {bool} [opts.minify=true]
      * @param {bool} [opts.minimizeAttributes=true] - Remove quotes when possible
      * @returns {string}
      * @memberOf mask
      * @method stringify
      */
    export function mask_stringify(input: any, opts?: any): any;
    export function mask_stringifyAttr(attr: any): string;
    export function format_Classes(cls: any): string;
}

declare module 'mask/parser/Templates' {
    export const Templates: {
        ensure(mix: any, ctx: {
            filename?: string;
        }): any;
    };
}

declare module 'mask/parser/cursor' {
    export function cursor_groupEnd(str: any, i: any, imax: any, startCode: any, endCode: any): any;
    export function cursor_refEnd(str: any, i: any, imax: any): any;
    export function cursor_tokenEnd(str: any, i: any, imax: any): any;
    export function cursor_quoteEnd(str: any, i: any, imax: any, char_: any): any;
    export function cursor_skipWhitespace(str: any, i_: any, imax: any): any;
    export function cursor_skipWhitespaceBack(str: any, i: any): any;
    export function cursor_goToWhitespace(str: any, i: any, imax: any): any;
}

